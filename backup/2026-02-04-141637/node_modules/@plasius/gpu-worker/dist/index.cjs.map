{"version":3,"sources":["../src/index.js"],"sourcesContent":["import { loadQueueWgsl as loadQueueWgslRaw } from \"@plasius/gpu-lock-free-queue\";\n\nexport const workerWgslUrl = (() => {\n  if (typeof __IMPORT_META_URL__ !== \"undefined\") {\n    return new URL(\"./worker.wgsl\", __IMPORT_META_URL__);\n  }\n  if (typeof __filename !== \"undefined\" && typeof require !== \"undefined\") {\n    const { pathToFileURL } = require(\"node:url\");\n    return new URL(\"./worker.wgsl\", pathToFileURL(__filename));\n  }\n  const base =\n    typeof process !== \"undefined\" && process.cwd\n      ? `file://${process.cwd()}/`\n      : \"file:///\";\n  return new URL(\"./worker.wgsl\", base);\n})();\n\nconst jobRegistry = [];\nlet nextJobType = 0;\n\nasync function loadWgslSource(options = {}) {\n  const { wgsl, url, fetcher = globalThis.fetch, baseUrl } = options ?? {};\n  if (typeof wgsl === \"string\") {\n    assertNotHtmlWgsl(wgsl, \"inline WGSL\");\n    return wgsl;\n  }\n  if (!url) {\n    return null;\n  }\n  const resolved = url instanceof URL ? url : new URL(url, baseUrl);\n  if (!fetcher) {\n    if (resolved.protocol !== \"file:\") {\n      throw new Error(\"No fetcher available for non-file WGSL URL.\");\n    }\n    const { readFile } = await import(\"fs/promises\");\n    const { fileURLToPath } = await import(\"url\");\n    const source = await readFile(fileURLToPath(resolved), \"utf8\");\n    assertNotHtmlWgsl(source, resolved.href);\n    return source;\n  }\n  const response = await fetcher(resolved);\n  if (!response.ok) {\n    const status = \"status\" in response ? response.status : \"unknown\";\n    const statusText = \"statusText\" in response ? response.statusText : \"\";\n    const detail = statusText ? `${status} ${statusText}` : `${status}`;\n    throw new Error(`Failed to load WGSL (${detail})`);\n  }\n  const source = await response.text();\n  assertNotHtmlWgsl(source, resolved.href);\n  return source;\n}\n\nfunction stripComments(source) {\n  return source\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\")\n    .replace(/\\/\\/.*$/gm, \"\");\n}\n\nfunction tokenize(source) {\n  return source.match(/[A-Za-z_][A-Za-z0-9_]*|[{}();<>,:=]/g) ?? [];\n}\n\nfunction isIdentifier(token) {\n  return /^[A-Za-z_][A-Za-z0-9_]*$/.test(token);\n}\n\nfunction readNameAfterType(tokens, startIndex) {\n  let i = startIndex;\n  if (tokens[i] === \"<\") {\n    let depth = 1;\n    i += 1;\n    while (i < tokens.length && depth > 0) {\n      if (tokens[i] === \"<\") {\n        depth += 1;\n      } else if (tokens[i] === \">\") {\n        depth -= 1;\n      }\n      i += 1;\n    }\n  }\n  return tokens[i];\n}\n\nfunction scanModuleNames(source) {\n  const cleaned = stripComments(source);\n  const tokens = tokenize(cleaned);\n  const names = [];\n  let depth = 0;\n  for (let i = 0; i < tokens.length; i += 1) {\n    const token = tokens[i];\n    if (token === \"{\") {\n      depth += 1;\n      continue;\n    }\n    if (token === \"}\") {\n      depth = Math.max(0, depth - 1);\n      continue;\n    }\n    if (depth !== 0) {\n      continue;\n    }\n    if (token === \"fn\") {\n      const name = tokens[i + 1];\n      if (isIdentifier(name)) {\n        names.push({ kind: \"fn\", name });\n      }\n      continue;\n    }\n    if (token === \"struct\") {\n      const name = tokens[i + 1];\n      if (isIdentifier(name)) {\n        names.push({ kind: \"struct\", name });\n      }\n      continue;\n    }\n    if (token === \"alias\") {\n      const name = tokens[i + 1];\n      if (isIdentifier(name)) {\n        names.push({ kind: \"alias\", name });\n      }\n      continue;\n    }\n    if (token === \"var\" || token === \"let\" || token === \"const\" || token === \"override\") {\n      const name = readNameAfterType(tokens, i + 1);\n      if (isIdentifier(name)) {\n        names.push({ kind: token, name });\n      }\n    }\n  }\n  return names;\n}\n\nfunction buildNameIndex(modules) {\n  const index = new Map();\n  for (const module of modules) {\n    for (const item of scanModuleNames(module.source)) {\n      const bucket = index.get(item.name) ?? [];\n      bucket.push({ kind: item.kind, module: module.name });\n      index.set(item.name, bucket);\n    }\n  }\n  return index;\n}\n\nfunction assertNoNameClashes(modules) {\n  const index = buildNameIndex(modules);\n  const clashes = [];\n  for (const [name, entries] of index.entries()) {\n    if (entries.length > 1) {\n      clashes.push({ name, entries });\n    }\n  }\n  if (clashes.length === 0) {\n    return;\n  }\n  const lines = [\"WGSL debug: identifier clashes detected:\"];\n  for (const clash of clashes) {\n    const locations = clash.entries\n      .map((entry) => `${entry.module} (${entry.kind})`)\n      .join(\", \");\n    lines.push(`- ${clash.name}: ${locations}`);\n  }\n  throw new Error(lines.join(\"\\n\"));\n}\n\nfunction assertNotHtmlWgsl(source, context) {\n  const sample = source.slice(0, 200).toLowerCase();\n  if (\n    sample.includes(\"<!doctype\") ||\n    sample.includes(\"<html\") ||\n    sample.includes(\"<meta\")\n  ) {\n    const label = context ? ` for ${context}` : \"\";\n    throw new Error(\n      `Expected WGSL${label} but received HTML. Check the URL or server root.`\n    );\n  }\n}\n\nfunction renameProcessJob(source, name) {\n  return source.replace(/\\bprocess_job\\b/g, name);\n}\n\nfunction getQueueCompatMap(source) {\n  if (!/\\bJobMeta\\b/.test(source)) {\n    return null;\n  }\n  return [{ from: /\\bJobMeta\\b/g, to: \"JobDesc\" }];\n}\n\nfunction applyCompatMap(source, map) {\n  if (!map || map.length === 0) {\n    return source;\n  }\n  let next = source;\n  for (const entry of map) {\n    next = next.replace(entry.from, entry.to);\n  }\n  return next;\n}\n\nfunction normalizeJobs(jobs) {\n  const normalized = jobs.map((job, index) => {\n    if (typeof job === \"string\") {\n      return {\n        jobType: index,\n        wgsl: job,\n        label: `job_${index}`,\n        sourceName: `job-${index}`,\n      };\n    }\n    if (!job || typeof job.wgsl !== \"string\") {\n      throw new Error(\"Job entries must provide WGSL source strings.\");\n    }\n    const jobType = job.jobType ?? index;\n    const label = job.label ?? `job_${jobType}`;\n    return {\n      jobType,\n      wgsl: job.wgsl,\n      label,\n      sourceName: job.sourceName ?? job.label ?? `job-${jobType}`,\n    };\n  });\n  const seen = new Set();\n  for (const job of normalized) {\n    if (seen.has(job.jobType)) {\n      throw new Error(`Duplicate job_type detected: ${job.jobType}`);\n    }\n    seen.add(job.jobType);\n  }\n  return normalized;\n}\n\nfunction buildProcessJobDispatch(jobs) {\n  const lines = [\n    \"fn process_job(job_index: u32, job_type: u32, payload_words: u32) {\",\n  ];\n  if (jobs.length === 0) {\n    lines.push(\"  return;\");\n    lines.push(\"}\");\n    return lines.join(\"\\n\");\n  }\n  jobs.forEach((job, idx) => {\n    const clause = idx === 0 ? \"if\" : \"else if\";\n    lines.push(`  ${clause} (job_type == ${job.jobType}u) {`);\n    lines.push(\n      `    ${job.entryName}(job_index, job_type, payload_words);`\n    );\n    lines.push(\"  }\");\n  });\n  lines.push(\"}\");\n  return lines.join(\"\\n\");\n}\n\nexport async function loadWorkerWgsl(options = {}) {\n  const { url = workerWgslUrl, fetcher } = options ?? {};\n  const source = await loadWgslSource({\n    url,\n    fetcher,\n    baseUrl: workerWgslUrl,\n  });\n  if (typeof source !== \"string\") {\n    throw new Error(\"Failed to load worker WGSL source.\");\n  }\n  return source;\n}\n\nexport async function loadQueueWgsl(options = {}) {\n  const { queueCompat = true, ...rest } = options ?? {};\n  const source = await loadQueueWgslRaw(rest);\n  if (typeof source !== \"string\") {\n    throw new Error(\"Failed to load queue WGSL source.\");\n  }\n  assertNotHtmlWgsl(source, rest?.url ? String(rest.url) : \"queue WGSL\");\n  if (!queueCompat) {\n    return source;\n  }\n  const compatMap = getQueueCompatMap(source);\n  return applyCompatMap(source, compatMap);\n}\n\nexport async function loadJobWgsl(options = {}) {\n  const { wgsl, url, fetcher, label } = options ?? {};\n  const source = await loadWgslSource({\n    wgsl,\n    url,\n    fetcher,\n    baseUrl: workerWgslUrl,\n  });\n  if (typeof source !== \"string\") {\n    throw new Error(\"loadJobWgsl requires a WGSL string or URL.\");\n  }\n  const jobType = nextJobType;\n  nextJobType += 1;\n  jobRegistry.push({\n    jobType,\n    wgsl: source,\n    label: label ?? `job_${jobType}`,\n    sourceName: label ?? `job-${jobType}`,\n  });\n  return jobType;\n}\n\nexport async function assembleWorkerWgsl(workerWgsl, options = {}) {\n  const {\n    queueWgsl,\n    queueUrl,\n    preludeWgsl,\n    preludeUrl,\n    fetcher,\n    jobs,\n    debug,\n    queueCompat = true,\n  } = options ?? {};\n  const rawQueueSource =\n    queueWgsl ?? (await loadQueueWgslRaw({ url: queueUrl, fetcher }));\n  const bodyRaw = workerWgsl ?? (await loadWorkerWgsl({ fetcher }));\n  const compatMap = queueCompat ? getQueueCompatMap(rawQueueSource) : null;\n  const queueSource = applyCompatMap(rawQueueSource, compatMap);\n  const preludeRaw =\n    preludeWgsl ??\n    (preludeUrl\n      ? await loadWgslSource({ url: preludeUrl, fetcher, baseUrl: workerWgslUrl })\n      : \"\");\n  if ((preludeWgsl || preludeUrl) && typeof preludeRaw !== \"string\") {\n    throw new Error(\"Failed to load prelude WGSL source.\");\n  }\n  const preludeSource =\n    typeof preludeRaw === \"string\" && preludeRaw.length > 0\n      ? applyCompatMap(preludeRaw, compatMap)\n      : \"\";\n  const body = applyCompatMap(bodyRaw, compatMap);\n  const jobList = normalizeJobs(\n    typeof jobs === \"undefined\" ? jobRegistry : jobs\n  );\n  if (!jobList || jobList.length === 0) {\n    return `${queueSource}\\n\\n${body}`;\n  }\n  const rewrittenJobs = jobList.map((job) => {\n    const source = applyCompatMap(job.wgsl, compatMap);\n    const hasProcessJob = /\\bfn\\s+process_job\\b/.test(source);\n    if (!hasProcessJob) {\n      throw new Error(\n        `Job ${job.sourceName} is missing a process_job() entry function.`\n      );\n    }\n    const entryName = `process_job__${job.jobType}`;\n    const renamed = renameProcessJob(source, entryName);\n    return { ...job, entryName, wgsl: renamed };\n  });\n  const dispatch = buildProcessJobDispatch(rewrittenJobs);\n  const modulesForDebug = debug\n    ? [\n        { name: \"queue.wgsl\", source: queueSource },\n        ...(preludeSource\n          ? [{ name: \"jobs.prelude.wgsl\", source: preludeSource }]\n          : []),\n        ...rewrittenJobs.map((job) => ({\n          name: job.sourceName,\n          source: job.wgsl,\n        })),\n        { name: \"jobs.dispatch.wgsl\", source: dispatch },\n        { name: \"worker.wgsl\", source: body },\n      ]\n    : null;\n  if (modulesForDebug) {\n    assertNoNameClashes(modulesForDebug);\n  }\n  const jobBlocks = rewrittenJobs\n    .map((job) => `// Job ${job.jobType}: ${job.label}\\n${job.wgsl}`)\n    .join(\"\\n\\n\");\n  const preludeBlock = preludeSource ? `${preludeSource}\\n\\n` : \"\";\n  return `${queueSource}\\n\\n${preludeBlock}${jobBlocks}\\n\\n${dispatch}\\n\\n${body}`;\n}\n\nfunction normalizeWorkgroups(value, label) {\n  if (typeof value === \"number\") {\n    return [value, 1, 1];\n  }\n  if (Array.isArray(value)) {\n    const [x = 0, y = 1, z = 1] = value;\n    return [x, y, z];\n  }\n  throw new Error(`Invalid workgroup count for ${label}.`);\n}\n\nfunction resolveWorkgroups(value, label) {\n  if (typeof value === \"function\") {\n    return normalizeWorkgroups(value(), label);\n  }\n  if (value == null) {\n    return null;\n  }\n  return normalizeWorkgroups(value, label);\n}\n\nfunction setBindGroups(pass, bindGroups) {\n  if (!bindGroups) {\n    return;\n  }\n  bindGroups.forEach((group, index) => {\n    if (group) {\n      pass.setBindGroup(index, group);\n    }\n  });\n}\n\nfunction computeWorkerWorkgroups(maxJobs, workgroupSize) {\n  const jobs =\n    typeof maxJobs === \"function\" ? Number(maxJobs()) : Number(maxJobs);\n  if (!Number.isFinite(jobs) || jobs <= 0) {\n    throw new Error(\"maxJobsPerDispatch must be a positive number.\");\n  }\n  const size = Number(workgroupSize);\n  if (!Number.isFinite(size) || size <= 0) {\n    throw new Error(\"workgroupSize must be a positive number.\");\n  }\n  return Math.max(1, Math.ceil(jobs / size));\n}\n\nexport function createWorkerLoop(options = {}) {\n  const {\n    device,\n    worker,\n    jobs = [],\n    workgroupSize = 64,\n    maxJobsPerDispatch,\n    rateHz,\n    label,\n    onTick,\n    onError,\n  } = options ?? {};\n\n  if (!device) {\n    throw new Error(\"createWorkerLoop requires a GPUDevice.\");\n  }\n  if (!worker || !worker.pipeline) {\n    throw new Error(\"createWorkerLoop requires a worker pipeline.\");\n  }\n\n  let running = false;\n  let handle = null;\n  let usingRaf = false;\n  const intervalMs =\n    Number.isFinite(rateHz) && rateHz > 0 ? 1000 / rateHz : null;\n\n  const tick = () => {\n    try {\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginComputePass(\n        label ? { label } : undefined\n      );\n\n      pass.setPipeline(worker.pipeline);\n      setBindGroups(pass, worker.bindGroups);\n\n      const explicitWorkerGroups =\n        resolveWorkgroups(worker.workgroups, \"worker\") ??\n        resolveWorkgroups(worker.workgroupCount, \"worker\") ??\n        resolveWorkgroups(worker.dispatch, \"worker\");\n\n      const workerGroups = explicitWorkerGroups\n        ? explicitWorkerGroups\n        : [computeWorkerWorkgroups(maxJobsPerDispatch, workgroupSize), 1, 1];\n\n      if (workerGroups[0] > 0) {\n        pass.dispatchWorkgroups(...workerGroups);\n      }\n\n      jobs.forEach((job, index) => {\n        if (!job || !job.pipeline) {\n          throw new Error(`Job pipeline missing at index ${index}.`);\n        }\n        pass.setPipeline(job.pipeline);\n        setBindGroups(pass, job.bindGroups);\n        const groups = resolveWorkgroups(\n          job.workgroups ?? job.workgroupCount ?? job.dispatch,\n          `job ${index}`\n        );\n        if (!groups) {\n          throw new Error(`Job ${index} requires a workgroup count.`);\n        }\n        if (groups[0] > 0) {\n          pass.dispatchWorkgroups(...groups);\n        }\n      });\n\n      pass.end();\n      device.queue.submit([encoder.finish()]);\n\n      if (onTick) {\n        onTick();\n      }\n    } catch (err) {\n      if (onError) {\n        onError(err);\n        return;\n      }\n      throw err;\n    }\n  };\n\n  const scheduleNext = () => {\n    if (!running) {\n      return;\n    }\n    if (intervalMs != null) {\n      tick();\n      usingRaf = false;\n      handle = setTimeout(scheduleNext, intervalMs);\n      return;\n    }\n    tick();\n    if (typeof requestAnimationFrame === \"function\") {\n      usingRaf = true;\n      handle = requestAnimationFrame(scheduleNext);\n    } else {\n      usingRaf = false;\n      handle = setTimeout(scheduleNext, 0);\n    }\n  };\n\n  const start = () => {\n    if (running) {\n      return;\n    }\n    running = true;\n    scheduleNext();\n  };\n\n  const stop = () => {\n    running = false;\n    if (handle == null) {\n      return;\n    }\n    if (usingRaf && typeof cancelAnimationFrame === \"function\") {\n      cancelAnimationFrame(handle);\n    } else {\n      clearTimeout(handle);\n    }\n    handle = null;\n  };\n\n  return {\n    start,\n    stop,\n    tick,\n    get running() {\n      return running;\n    },\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAAkD;AAE3C,IAAM,iBAAiB,MAAM;AAClC,MAAI,OAA4C;AAC9C,WAAO,IAAI,IAAI,iBAAiB,MAAmB;AAAA,EACrD;AACA,MAAI,OAAO,eAAe,eAAe,OAAO,YAAY,aAAa;AACvE,UAAM,EAAE,cAAc,IAAI,QAAQ,KAAU;AAC5C,WAAO,IAAI,IAAI,iBAAiB,cAAc,UAAU,CAAC;AAAA,EAC3D;AACA,QAAM,OACJ,OAAO,YAAY,eAAe,QAAQ,MACtC,UAAU,QAAQ,IAAI,CAAC,MACvB;AACN,SAAO,IAAI,IAAI,iBAAiB,IAAI;AACtC,GAAG;AAEH,IAAM,cAAc,CAAC;AACrB,IAAI,cAAc;AAElB,eAAe,eAAe,UAAU,CAAC,GAAG;AAC1C,QAAM,EAAE,MAAM,KAAK,UAAU,WAAW,OAAO,QAAQ,IAAI,WAAW,CAAC;AACvE,MAAI,OAAO,SAAS,UAAU;AAC5B,sBAAkB,MAAM,aAAa;AACrC,WAAO;AAAA,EACT;AACA,MAAI,CAAC,KAAK;AACR,WAAO;AAAA,EACT;AACA,QAAM,WAAW,eAAe,MAAM,MAAM,IAAI,IAAI,KAAK,OAAO;AAChE,MAAI,CAAC,SAAS;AACZ,QAAI,SAAS,aAAa,SAAS;AACjC,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,UAAM,EAAE,SAAS,IAAI,MAAM,OAAO,aAAa;AAC/C,UAAM,EAAE,cAAc,IAAI,MAAM,OAAO,KAAK;AAC5C,UAAMA,UAAS,MAAM,SAAS,cAAc,QAAQ,GAAG,MAAM;AAC7D,sBAAkBA,SAAQ,SAAS,IAAI;AACvC,WAAOA;AAAA,EACT;AACA,QAAM,WAAW,MAAM,QAAQ,QAAQ;AACvC,MAAI,CAAC,SAAS,IAAI;AAChB,UAAM,SAAS,YAAY,WAAW,SAAS,SAAS;AACxD,UAAM,aAAa,gBAAgB,WAAW,SAAS,aAAa;AACpE,UAAM,SAAS,aAAa,GAAG,MAAM,IAAI,UAAU,KAAK,GAAG,MAAM;AACjE,UAAM,IAAI,MAAM,wBAAwB,MAAM,GAAG;AAAA,EACnD;AACA,QAAM,SAAS,MAAM,SAAS,KAAK;AACnC,oBAAkB,QAAQ,SAAS,IAAI;AACvC,SAAO;AACT;AAEA,SAAS,cAAc,QAAQ;AAC7B,SAAO,OACJ,QAAQ,qBAAqB,EAAE,EAC/B,QAAQ,aAAa,EAAE;AAC5B;AAEA,SAAS,SAAS,QAAQ;AACxB,SAAO,OAAO,MAAM,sCAAsC,KAAK,CAAC;AAClE;AAEA,SAAS,aAAa,OAAO;AAC3B,SAAO,2BAA2B,KAAK,KAAK;AAC9C;AAEA,SAAS,kBAAkB,QAAQ,YAAY;AAC7C,MAAI,IAAI;AACR,MAAI,OAAO,CAAC,MAAM,KAAK;AACrB,QAAI,QAAQ;AACZ,SAAK;AACL,WAAO,IAAI,OAAO,UAAU,QAAQ,GAAG;AACrC,UAAI,OAAO,CAAC,MAAM,KAAK;AACrB,iBAAS;AAAA,MACX,WAAW,OAAO,CAAC,MAAM,KAAK;AAC5B,iBAAS;AAAA,MACX;AACA,WAAK;AAAA,IACP;AAAA,EACF;AACA,SAAO,OAAO,CAAC;AACjB;AAEA,SAAS,gBAAgB,QAAQ;AAC/B,QAAM,UAAU,cAAc,MAAM;AACpC,QAAM,SAAS,SAAS,OAAO;AAC/B,QAAM,QAAQ,CAAC;AACf,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,UAAM,QAAQ,OAAO,CAAC;AACtB,QAAI,UAAU,KAAK;AACjB,eAAS;AACT;AAAA,IACF;AACA,QAAI,UAAU,KAAK;AACjB,cAAQ,KAAK,IAAI,GAAG,QAAQ,CAAC;AAC7B;AAAA,IACF;AACA,QAAI,UAAU,GAAG;AACf;AAAA,IACF;AACA,QAAI,UAAU,MAAM;AAClB,YAAM,OAAO,OAAO,IAAI,CAAC;AACzB,UAAI,aAAa,IAAI,GAAG;AACtB,cAAM,KAAK,EAAE,MAAM,MAAM,KAAK,CAAC;AAAA,MACjC;AACA;AAAA,IACF;AACA,QAAI,UAAU,UAAU;AACtB,YAAM,OAAO,OAAO,IAAI,CAAC;AACzB,UAAI,aAAa,IAAI,GAAG;AACtB,cAAM,KAAK,EAAE,MAAM,UAAU,KAAK,CAAC;AAAA,MACrC;AACA;AAAA,IACF;AACA,QAAI,UAAU,SAAS;AACrB,YAAM,OAAO,OAAO,IAAI,CAAC;AACzB,UAAI,aAAa,IAAI,GAAG;AACtB,cAAM,KAAK,EAAE,MAAM,SAAS,KAAK,CAAC;AAAA,MACpC;AACA;AAAA,IACF;AACA,QAAI,UAAU,SAAS,UAAU,SAAS,UAAU,WAAW,UAAU,YAAY;AACnF,YAAM,OAAO,kBAAkB,QAAQ,IAAI,CAAC;AAC5C,UAAI,aAAa,IAAI,GAAG;AACtB,cAAM,KAAK,EAAE,MAAM,OAAO,KAAK,CAAC;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,eAAe,SAAS;AAC/B,QAAM,QAAQ,oBAAI,IAAI;AACtB,aAAWC,WAAU,SAAS;AAC5B,eAAW,QAAQ,gBAAgBA,QAAO,MAAM,GAAG;AACjD,YAAM,SAAS,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC;AACxC,aAAO,KAAK,EAAE,MAAM,KAAK,MAAM,QAAQA,QAAO,KAAK,CAAC;AACpD,YAAM,IAAI,KAAK,MAAM,MAAM;AAAA,IAC7B;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,oBAAoB,SAAS;AACpC,QAAM,QAAQ,eAAe,OAAO;AACpC,QAAM,UAAU,CAAC;AACjB,aAAW,CAAC,MAAM,OAAO,KAAK,MAAM,QAAQ,GAAG;AAC7C,QAAI,QAAQ,SAAS,GAAG;AACtB,cAAQ,KAAK,EAAE,MAAM,QAAQ,CAAC;AAAA,IAChC;AAAA,EACF;AACA,MAAI,QAAQ,WAAW,GAAG;AACxB;AAAA,EACF;AACA,QAAM,QAAQ,CAAC,0CAA0C;AACzD,aAAW,SAAS,SAAS;AAC3B,UAAM,YAAY,MAAM,QACrB,IAAI,CAAC,UAAU,GAAG,MAAM,MAAM,KAAK,MAAM,IAAI,GAAG,EAChD,KAAK,IAAI;AACZ,UAAM,KAAK,KAAK,MAAM,IAAI,KAAK,SAAS,EAAE;AAAA,EAC5C;AACA,QAAM,IAAI,MAAM,MAAM,KAAK,IAAI,CAAC;AAClC;AAEA,SAAS,kBAAkB,QAAQ,SAAS;AAC1C,QAAM,SAAS,OAAO,MAAM,GAAG,GAAG,EAAE,YAAY;AAChD,MACE,OAAO,SAAS,WAAW,KAC3B,OAAO,SAAS,OAAO,KACvB,OAAO,SAAS,OAAO,GACvB;AACA,UAAM,QAAQ,UAAU,QAAQ,OAAO,KAAK;AAC5C,UAAM,IAAI;AAAA,MACR,gBAAgB,KAAK;AAAA,IACvB;AAAA,EACF;AACF;AAEA,SAAS,iBAAiB,QAAQ,MAAM;AACtC,SAAO,OAAO,QAAQ,oBAAoB,IAAI;AAChD;AAEA,SAAS,kBAAkB,QAAQ;AACjC,MAAI,CAAC,cAAc,KAAK,MAAM,GAAG;AAC/B,WAAO;AAAA,EACT;AACA,SAAO,CAAC,EAAE,MAAM,gBAAgB,IAAI,UAAU,CAAC;AACjD;AAEA,SAAS,eAAe,QAAQ,KAAK;AACnC,MAAI,CAAC,OAAO,IAAI,WAAW,GAAG;AAC5B,WAAO;AAAA,EACT;AACA,MAAI,OAAO;AACX,aAAW,SAAS,KAAK;AACvB,WAAO,KAAK,QAAQ,MAAM,MAAM,MAAM,EAAE;AAAA,EAC1C;AACA,SAAO;AACT;AAEA,SAAS,cAAc,MAAM;AAC3B,QAAM,aAAa,KAAK,IAAI,CAAC,KAAK,UAAU;AAC1C,QAAI,OAAO,QAAQ,UAAU;AAC3B,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO,OAAO,KAAK;AAAA,QACnB,YAAY,OAAO,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,OAAO,OAAO,IAAI,SAAS,UAAU;AACxC,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AACA,UAAM,UAAU,IAAI,WAAW;AAC/B,UAAM,QAAQ,IAAI,SAAS,OAAO,OAAO;AACzC,WAAO;AAAA,MACL;AAAA,MACA,MAAM,IAAI;AAAA,MACV;AAAA,MACA,YAAY,IAAI,cAAc,IAAI,SAAS,OAAO,OAAO;AAAA,IAC3D;AAAA,EACF,CAAC;AACD,QAAM,OAAO,oBAAI,IAAI;AACrB,aAAW,OAAO,YAAY;AAC5B,QAAI,KAAK,IAAI,IAAI,OAAO,GAAG;AACzB,YAAM,IAAI,MAAM,gCAAgC,IAAI,OAAO,EAAE;AAAA,IAC/D;AACA,SAAK,IAAI,IAAI,OAAO;AAAA,EACtB;AACA,SAAO;AACT;AAEA,SAAS,wBAAwB,MAAM;AACrC,QAAM,QAAQ;AAAA,IACZ;AAAA,EACF;AACA,MAAI,KAAK,WAAW,GAAG;AACrB,UAAM,KAAK,WAAW;AACtB,UAAM,KAAK,GAAG;AACd,WAAO,MAAM,KAAK,IAAI;AAAA,EACxB;AACA,OAAK,QAAQ,CAAC,KAAK,QAAQ;AACzB,UAAM,SAAS,QAAQ,IAAI,OAAO;AAClC,UAAM,KAAK,KAAK,MAAM,iBAAiB,IAAI,OAAO,MAAM;AACxD,UAAM;AAAA,MACJ,OAAO,IAAI,SAAS;AAAA,IACtB;AACA,UAAM,KAAK,KAAK;AAAA,EAClB,CAAC;AACD,QAAM,KAAK,GAAG;AACd,SAAO,MAAM,KAAK,IAAI;AACxB;AAEA,eAAsB,eAAe,UAAU,CAAC,GAAG;AACjD,QAAM,EAAE,MAAM,eAAe,QAAQ,IAAI,WAAW,CAAC;AACrD,QAAM,SAAS,MAAM,eAAe;AAAA,IAClC;AAAA,IACA;AAAA,IACA,SAAS;AAAA,EACX,CAAC;AACD,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACtD;AACA,SAAO;AACT;AAEA,eAAsB,cAAc,UAAU,CAAC,GAAG;AAChD,QAAM,EAAE,cAAc,MAAM,GAAG,KAAK,IAAI,WAAW,CAAC;AACpD,QAAM,SAAS,UAAM,2BAAAC,eAAiB,IAAI;AAC1C,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,MAAM,mCAAmC;AAAA,EACrD;AACA,oBAAkB,QAAQ,MAAM,MAAM,OAAO,KAAK,GAAG,IAAI,YAAY;AACrE,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AACA,QAAM,YAAY,kBAAkB,MAAM;AAC1C,SAAO,eAAe,QAAQ,SAAS;AACzC;AAEA,eAAsB,YAAY,UAAU,CAAC,GAAG;AAC9C,QAAM,EAAE,MAAM,KAAK,SAAS,MAAM,IAAI,WAAW,CAAC;AAClD,QAAM,SAAS,MAAM,eAAe;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,EACX,CAAC;AACD,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AACA,QAAM,UAAU;AAChB,iBAAe;AACf,cAAY,KAAK;AAAA,IACf;AAAA,IACA,MAAM;AAAA,IACN,OAAO,SAAS,OAAO,OAAO;AAAA,IAC9B,YAAY,SAAS,OAAO,OAAO;AAAA,EACrC,CAAC;AACD,SAAO;AACT;AAEA,eAAsB,mBAAmB,YAAY,UAAU,CAAC,GAAG;AACjE,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,cAAc;AAAA,EAChB,IAAI,WAAW,CAAC;AAChB,QAAM,iBACJ,aAAc,UAAM,2BAAAA,eAAiB,EAAE,KAAK,UAAU,QAAQ,CAAC;AACjE,QAAM,UAAU,cAAe,MAAM,eAAe,EAAE,QAAQ,CAAC;AAC/D,QAAM,YAAY,cAAc,kBAAkB,cAAc,IAAI;AACpE,QAAM,cAAc,eAAe,gBAAgB,SAAS;AAC5D,QAAM,aACJ,gBACC,aACG,MAAM,eAAe,EAAE,KAAK,YAAY,SAAS,SAAS,cAAc,CAAC,IACzE;AACN,OAAK,eAAe,eAAe,OAAO,eAAe,UAAU;AACjE,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACvD;AACA,QAAM,gBACJ,OAAO,eAAe,YAAY,WAAW,SAAS,IAClD,eAAe,YAAY,SAAS,IACpC;AACN,QAAM,OAAO,eAAe,SAAS,SAAS;AAC9C,QAAM,UAAU;AAAA,IACd,OAAO,SAAS,cAAc,cAAc;AAAA,EAC9C;AACA,MAAI,CAAC,WAAW,QAAQ,WAAW,GAAG;AACpC,WAAO,GAAG,WAAW;AAAA;AAAA,EAAO,IAAI;AAAA,EAClC;AACA,QAAM,gBAAgB,QAAQ,IAAI,CAAC,QAAQ;AACzC,UAAM,SAAS,eAAe,IAAI,MAAM,SAAS;AACjD,UAAM,gBAAgB,uBAAuB,KAAK,MAAM;AACxD,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR,OAAO,IAAI,UAAU;AAAA,MACvB;AAAA,IACF;AACA,UAAM,YAAY,gBAAgB,IAAI,OAAO;AAC7C,UAAM,UAAU,iBAAiB,QAAQ,SAAS;AAClD,WAAO,EAAE,GAAG,KAAK,WAAW,MAAM,QAAQ;AAAA,EAC5C,CAAC;AACD,QAAM,WAAW,wBAAwB,aAAa;AACtD,QAAM,kBAAkB,QACpB;AAAA,IACE,EAAE,MAAM,cAAc,QAAQ,YAAY;AAAA,IAC1C,GAAI,gBACA,CAAC,EAAE,MAAM,qBAAqB,QAAQ,cAAc,CAAC,IACrD,CAAC;AAAA,IACL,GAAG,cAAc,IAAI,CAAC,SAAS;AAAA,MAC7B,MAAM,IAAI;AAAA,MACV,QAAQ,IAAI;AAAA,IACd,EAAE;AAAA,IACF,EAAE,MAAM,sBAAsB,QAAQ,SAAS;AAAA,IAC/C,EAAE,MAAM,eAAe,QAAQ,KAAK;AAAA,EACtC,IACA;AACJ,MAAI,iBAAiB;AACnB,wBAAoB,eAAe;AAAA,EACrC;AACA,QAAM,YAAY,cACf,IAAI,CAAC,QAAQ,UAAU,IAAI,OAAO,KAAK,IAAI,KAAK;AAAA,EAAK,IAAI,IAAI,EAAE,EAC/D,KAAK,MAAM;AACd,QAAM,eAAe,gBAAgB,GAAG,aAAa;AAAA;AAAA,IAAS;AAC9D,SAAO,GAAG,WAAW;AAAA;AAAA,EAAO,YAAY,GAAG,SAAS;AAAA;AAAA,EAAO,QAAQ;AAAA;AAAA,EAAO,IAAI;AAChF;AAEA,SAAS,oBAAoB,OAAO,OAAO;AACzC,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,CAAC,OAAO,GAAG,CAAC;AAAA,EACrB;AACA,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,UAAM,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,IAAI;AAC9B,WAAO,CAAC,GAAG,GAAG,CAAC;AAAA,EACjB;AACA,QAAM,IAAI,MAAM,+BAA+B,KAAK,GAAG;AACzD;AAEA,SAAS,kBAAkB,OAAO,OAAO;AACvC,MAAI,OAAO,UAAU,YAAY;AAC/B,WAAO,oBAAoB,MAAM,GAAG,KAAK;AAAA,EAC3C;AACA,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AACA,SAAO,oBAAoB,OAAO,KAAK;AACzC;AAEA,SAAS,cAAc,MAAM,YAAY;AACvC,MAAI,CAAC,YAAY;AACf;AAAA,EACF;AACA,aAAW,QAAQ,CAAC,OAAO,UAAU;AACnC,QAAI,OAAO;AACT,WAAK,aAAa,OAAO,KAAK;AAAA,IAChC;AAAA,EACF,CAAC;AACH;AAEA,SAAS,wBAAwB,SAAS,eAAe;AACvD,QAAM,OACJ,OAAO,YAAY,aAAa,OAAO,QAAQ,CAAC,IAAI,OAAO,OAAO;AACpE,MAAI,CAAC,OAAO,SAAS,IAAI,KAAK,QAAQ,GAAG;AACvC,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACjE;AACA,QAAM,OAAO,OAAO,aAAa;AACjC,MAAI,CAAC,OAAO,SAAS,IAAI,KAAK,QAAQ,GAAG;AACvC,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AACA,SAAO,KAAK,IAAI,GAAG,KAAK,KAAK,OAAO,IAAI,CAAC;AAC3C;AAEO,SAAS,iBAAiB,UAAU,CAAC,GAAG;AAC7C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,IACR,gBAAgB;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,WAAW,CAAC;AAEhB,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,wCAAwC;AAAA,EAC1D;AACA,MAAI,CAAC,UAAU,CAAC,OAAO,UAAU;AAC/B,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AAEA,MAAI,UAAU;AACd,MAAI,SAAS;AACb,MAAI,WAAW;AACf,QAAM,aACJ,OAAO,SAAS,MAAM,KAAK,SAAS,IAAI,MAAO,SAAS;AAE1D,QAAM,OAAO,MAAM;AACjB,QAAI;AACF,YAAM,UAAU,OAAO,qBAAqB;AAC5C,YAAM,OAAO,QAAQ;AAAA,QACnB,QAAQ,EAAE,MAAM,IAAI;AAAA,MACtB;AAEA,WAAK,YAAY,OAAO,QAAQ;AAChC,oBAAc,MAAM,OAAO,UAAU;AAErC,YAAM,uBACJ,kBAAkB,OAAO,YAAY,QAAQ,KAC7C,kBAAkB,OAAO,gBAAgB,QAAQ,KACjD,kBAAkB,OAAO,UAAU,QAAQ;AAE7C,YAAM,eAAe,uBACjB,uBACA,CAAC,wBAAwB,oBAAoB,aAAa,GAAG,GAAG,CAAC;AAErE,UAAI,aAAa,CAAC,IAAI,GAAG;AACvB,aAAK,mBAAmB,GAAG,YAAY;AAAA,MACzC;AAEA,WAAK,QAAQ,CAAC,KAAK,UAAU;AAC3B,YAAI,CAAC,OAAO,CAAC,IAAI,UAAU;AACzB,gBAAM,IAAI,MAAM,iCAAiC,KAAK,GAAG;AAAA,QAC3D;AACA,aAAK,YAAY,IAAI,QAAQ;AAC7B,sBAAc,MAAM,IAAI,UAAU;AAClC,cAAM,SAAS;AAAA,UACb,IAAI,cAAc,IAAI,kBAAkB,IAAI;AAAA,UAC5C,OAAO,KAAK;AAAA,QACd;AACA,YAAI,CAAC,QAAQ;AACX,gBAAM,IAAI,MAAM,OAAO,KAAK,8BAA8B;AAAA,QAC5D;AACA,YAAI,OAAO,CAAC,IAAI,GAAG;AACjB,eAAK,mBAAmB,GAAG,MAAM;AAAA,QACnC;AAAA,MACF,CAAC;AAED,WAAK,IAAI;AACT,aAAO,MAAM,OAAO,CAAC,QAAQ,OAAO,CAAC,CAAC;AAEtC,UAAI,QAAQ;AACV,eAAO;AAAA,MACT;AAAA,IACF,SAAS,KAAK;AACZ,UAAI,SAAS;AACX,gBAAQ,GAAG;AACX;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,QAAM,eAAe,MAAM;AACzB,QAAI,CAAC,SAAS;AACZ;AAAA,IACF;AACA,QAAI,cAAc,MAAM;AACtB,WAAK;AACL,iBAAW;AACX,eAAS,WAAW,cAAc,UAAU;AAC5C;AAAA,IACF;AACA,SAAK;AACL,QAAI,OAAO,0BAA0B,YAAY;AAC/C,iBAAW;AACX,eAAS,sBAAsB,YAAY;AAAA,IAC7C,OAAO;AACL,iBAAW;AACX,eAAS,WAAW,cAAc,CAAC;AAAA,IACrC;AAAA,EACF;AAEA,QAAM,QAAQ,MAAM;AAClB,QAAI,SAAS;AACX;AAAA,IACF;AACA,cAAU;AACV,iBAAa;AAAA,EACf;AAEA,QAAM,OAAO,MAAM;AACjB,cAAU;AACV,QAAI,UAAU,MAAM;AAClB;AAAA,IACF;AACA,QAAI,YAAY,OAAO,yBAAyB,YAAY;AAC1D,2BAAqB,MAAM;AAAA,IAC7B,OAAO;AACL,mBAAa,MAAM;AAAA,IACrB;AACA,aAAS;AAAA,EACX;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,IAAI,UAAU;AACZ,aAAO;AAAA,IACT;AAAA,EACF;AACF;","names":["source","module","loadQueueWgslRaw"]}