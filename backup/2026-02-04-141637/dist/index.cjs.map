{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/hex.ts","../src/generator.ts","../src/wgsl.ts","../src/fields.ts","../src/biomes/temperate.ts","../src/perf-monitor.ts","../src/fractal-prepass.ts","../src/tiles.ts","../src/tile-cache.ts","../src/mesh.ts"],"sourcesContent":["export * from \"./types\";\nexport * from \"./hex\";\nexport * from \"./generator\";\nexport * from \"./wgsl\";\nexport * from \"./fields\";\nexport * from \"./biomes/temperate\";\nexport * from \"./perf-monitor\";\nexport * from \"./fractal-prepass\";\nexport * from \"./tiles\";\nexport * from \"./tile-cache\";\nexport * from \"./mesh\";\n","export const TerrainBiome = {\n  Plains: 0,\n  Tundra: 1,\n  Savanna: 2,\n  River: 3,\n  City: 4,\n  Village: 5,\n  Ice: 6,\n  Snow: 7,\n  Mountainous: 8,\n  Volcanic: 9,\n  Road: 10,\n  Town: 11,\n  Castle: 12,\n  MixedForest: 13,\n} as const;\n\nexport type TerrainBiomeId = (typeof TerrainBiome)[keyof typeof TerrainBiome];\n\nexport const TerrainBiomeLabel: Record<TerrainBiomeId, string> = {\n  [TerrainBiome.Plains]: \"Plains\",\n  [TerrainBiome.Tundra]: \"Tundra\",\n  [TerrainBiome.Savanna]: \"Savanna\",\n  [TerrainBiome.River]: \"River\",\n  [TerrainBiome.City]: \"City\",\n  [TerrainBiome.Village]: \"Village\",\n  [TerrainBiome.Ice]: \"Ice\",\n  [TerrainBiome.Snow]: \"Snow\",\n  [TerrainBiome.Mountainous]: \"Mountainous\",\n  [TerrainBiome.Volcanic]: \"Volcanic\",\n  [TerrainBiome.Road]: \"Road\",\n  [TerrainBiome.Town]: \"Town\",\n  [TerrainBiome.Castle]: \"Castle\",\n  [TerrainBiome.MixedForest]: \"Mixed Forest\",\n};\n\nexport const MacroBiome = {\n  Polar: 0,\n  ColdTemperate: 1,\n  Temperate: 2,\n  Arid: 3,\n  Tropical: 4,\n  Alpine: 5,\n  Volcanic: 6,\n  Freshwater: 7,\n  Coastal: 8,\n  Urban: 9,\n  Underground: 10,\n} as const;\n\nexport type MacroBiomeId = (typeof MacroBiome)[keyof typeof MacroBiome];\n\nexport const MacroBiomeLabel: Record<MacroBiomeId, string> = {\n  [MacroBiome.Polar]: \"Polar\",\n  [MacroBiome.ColdTemperate]: \"Cold Temperate\",\n  [MacroBiome.Temperate]: \"Temperate\",\n  [MacroBiome.Arid]: \"Arid\",\n  [MacroBiome.Tropical]: \"Tropical\",\n  [MacroBiome.Alpine]: \"Alpine\",\n  [MacroBiome.Volcanic]: \"Volcanic\",\n  [MacroBiome.Freshwater]: \"Freshwater\",\n  [MacroBiome.Coastal]: \"Coastal\",\n  [MacroBiome.Urban]: \"Urban\",\n  [MacroBiome.Underground]: \"Underground\",\n};\n\nexport const SurfaceCover = {\n  Grass: 0,\n  Dirt: 1,\n  Sand: 2,\n  Rock: 3,\n  Gravel: 4,\n  Snowpack: 5,\n  Ice: 6,\n  Mud: 7,\n  Ash: 8,\n  Cobble: 9,\n  Road: 10,\n  Water: 11,\n  Basalt: 12,\n  Crystal: 13,\n  Sludge: 14,\n} as const;\n\nexport type SurfaceCoverId = (typeof SurfaceCover)[keyof typeof SurfaceCover];\n\nexport const SurfaceCoverLabel: Record<SurfaceCoverId, string> = {\n  [SurfaceCover.Grass]: \"Grass\",\n  [SurfaceCover.Dirt]: \"Dirt\",\n  [SurfaceCover.Sand]: \"Sand\",\n  [SurfaceCover.Rock]: \"Rock\",\n  [SurfaceCover.Gravel]: \"Gravel\",\n  [SurfaceCover.Snowpack]: \"Snowpack\",\n  [SurfaceCover.Ice]: \"Ice\",\n  [SurfaceCover.Mud]: \"Mud\",\n  [SurfaceCover.Ash]: \"Ash\",\n  [SurfaceCover.Cobble]: \"Cobble\",\n  [SurfaceCover.Road]: \"Road\",\n  [SurfaceCover.Water]: \"Water\",\n  [SurfaceCover.Basalt]: \"Basalt\",\n  [SurfaceCover.Crystal]: \"Crystal\",\n  [SurfaceCover.Sludge]: \"Sludge\",\n};\n\nexport const MicroFeature = {\n  Tree: 0,\n  Bush: 1,\n  GrassTuft: 2,\n  Reed: 3,\n  Rock: 4,\n  Boulder: 5,\n  WaterRipple: 6,\n  IceSpike: 7,\n  Hut: 8,\n  Wall: 9,\n  Bridge: 10,\n  Gate: 11,\n  Tower: 12,\n  Ruin: 13,\n  Stalactite: 14,\n  Stalagmite: 15,\n  CrystalSpire: 16,\n  Mushroom: 17,\n  TimberSupport: 18,\n  Rail: 19,\n  Cart: 20,\n  Lantern: 21,\n  Grate: 22,\n  BrickTunnel: 23,\n} as const;\n\nexport type MicroFeatureId = (typeof MicroFeature)[keyof typeof MicroFeature];\n\nexport const MicroFeatureLabel: Record<MicroFeatureId, string> = {\n  [MicroFeature.Tree]: \"Tree\",\n  [MicroFeature.Bush]: \"Bush\",\n  [MicroFeature.GrassTuft]: \"Grass Tuft\",\n  [MicroFeature.Reed]: \"Reed\",\n  [MicroFeature.Rock]: \"Rock\",\n  [MicroFeature.Boulder]: \"Boulder\",\n  [MicroFeature.WaterRipple]: \"Water Ripple\",\n  [MicroFeature.IceSpike]: \"Ice Spike\",\n  [MicroFeature.Hut]: \"Hut\",\n  [MicroFeature.Wall]: \"Wall\",\n  [MicroFeature.Bridge]: \"Bridge\",\n  [MicroFeature.Gate]: \"Gate\",\n  [MicroFeature.Tower]: \"Tower\",\n  [MicroFeature.Ruin]: \"Ruin\",\n  [MicroFeature.Stalactite]: \"Stalactite\",\n  [MicroFeature.Stalagmite]: \"Stalagmite\",\n  [MicroFeature.CrystalSpire]: \"Crystal Spire\",\n  [MicroFeature.Mushroom]: \"Mushroom\",\n  [MicroFeature.TimberSupport]: \"Timber Support\",\n  [MicroFeature.Rail]: \"Rail\",\n  [MicroFeature.Cart]: \"Cart\",\n  [MicroFeature.Lantern]: \"Lantern\",\n  [MicroFeature.Grate]: \"Grate\",\n  [MicroFeature.BrickTunnel]: \"Brick Tunnel\",\n};\n\nexport interface HexCell {\n  q: number;\n  r: number;\n  level: number;\n  flags?: number;\n}\n\nexport interface TerrainCell {\n  height: number;\n  heat: number;\n  moisture: number;\n  biome: TerrainBiomeId;\n  macroBiome?: MacroBiomeId;\n  surface?: SurfaceCoverId;\n  feature?: MicroFeatureId;\n}\n\nexport interface TerrainParams {\n  seed: number;\n  cellCount: number;\n  heatBias?: number;\n  heightScale?: number;\n  macroScale?: number;\n  macroWarpStrength?: number;\n  styleMixStrength?: number;\n  terraceSteps?: number;\n  terraceStrength?: number;\n  craterStrength?: number;\n  craterScale?: number;\n  heightMin?: number;\n  heightMax?: number;\n}\n\nexport interface HexLevelSpec {\n  level: number;\n  areaM2: number;\n  sideMeters: number;\n  acrossFlatsMeters: number;\n}\n","import type { HexCell, HexLevelSpec } from \"./types\";\n\nconst HEX_AREA_FACTOR = (3 * Math.sqrt(3)) / 2;\n\nexport function hexAreaFromSide(sideMeters: number): number {\n  return HEX_AREA_FACTOR * sideMeters * sideMeters;\n}\n\nexport function hexSideFromArea(areaM2: number): number {\n  return Math.sqrt(areaM2 / HEX_AREA_FACTOR);\n}\n\nexport function axialToWorld(q: number, r: number, sizeMeters: number) {\n  const x = sizeMeters * (Math.sqrt(3) * q + (Math.sqrt(3) / 2) * r);\n  const y = sizeMeters * (1.5 * r);\n  return { x, y };\n}\n\nexport function generateHexGrid(radius: number, level = 0): HexCell[] {\n  const cells: HexCell[] = [];\n  for (let q = -radius; q <= radius; q += 1) {\n    const r1 = Math.max(-radius, -q - radius);\n    const r2 = Math.min(radius, -q + radius);\n    for (let r = r1; r <= r2; r += 1) {\n      cells.push({ q, r, level, flags: 0 });\n    }\n  }\n  return cells;\n}\n\nexport function buildHexLevels(options: {\n  topAreaKm2?: number;\n  minAreaM2?: number;\n  levels?: number;\n} = {}): HexLevelSpec[] {\n  const topAreaKm2 = options.topAreaKm2 ?? 1000;\n  const minAreaM2 = options.minAreaM2 ?? 10;\n  const levels = Math.max(2, options.levels ?? 6);\n  const topAreaM2 = topAreaKm2 * 1_000_000;\n  const ratio = Math.pow(topAreaM2 / minAreaM2, 1 / (levels - 1));\n\n  const specs: HexLevelSpec[] = [];\n  for (let level = 0; level < levels; level += 1) {\n    const areaM2 = topAreaM2 / Math.pow(ratio, level);\n    const sideMeters = hexSideFromArea(areaM2);\n    specs.push({\n      level,\n      areaM2,\n      sideMeters,\n      acrossFlatsMeters: sideMeters * Math.sqrt(3),\n    });\n  }\n  return specs;\n}\n","import type { HexCell, TerrainCell, TerrainParams, TerrainBiomeId } from \"./types\";\n\nexport function packHexCells(cells: HexCell[]): Int32Array {\n  const data = new Int32Array(cells.length * 4);\n  cells.forEach((cell, i) => {\n    const base = i * 4;\n    data[base] = cell.q | 0;\n    data[base + 1] = cell.r | 0;\n    data[base + 2] = cell.level | 0;\n    data[base + 3] = cell.flags ?? 0;\n  });\n  return data;\n}\n\nexport function encodeTerrainParams(params: TerrainParams): ArrayBuffer {\n  const buffer = new ArrayBuffer(16 * 4);\n  const u32 = new Uint32Array(buffer);\n  const f32 = new Float32Array(buffer);\n  u32[0] = params.seed >>> 0;\n  u32[1] = params.cellCount >>> 0;\n  f32[2] = params.heatBias ?? 0;\n  f32[3] = params.heightScale ?? 1;\n  f32[4] = params.macroScale ?? 0.035;\n  f32[5] = params.macroWarpStrength ?? 0.18;\n  f32[6] = params.styleMixStrength ?? 1.0;\n  f32[7] = params.terraceSteps ?? 6;\n  f32[8] = params.terraceStrength ?? 0.35;\n  f32[9] = params.craterStrength ?? 0.25;\n  f32[10] = params.craterScale ?? 0.18;\n  f32[11] = params.heightMin ?? -0.35;\n  f32[12] = params.heightMax ?? 1.6;\n  f32[13] = 0;\n  f32[14] = 0;\n  f32[15] = 0;\n  return buffer;\n}\n\nexport function unpackTerrain(buffer: ArrayBuffer): TerrainCell[] {\n  const f32 = new Float32Array(buffer);\n  const u32 = new Uint32Array(buffer);\n  const count = Math.floor(f32.length / 4);\n  const cells: TerrainCell[] = [];\n  for (let i = 0; i < count; i += 1) {\n    const base = i * 4;\n    cells.push({\n      height: f32[base],\n      heat: f32[base + 1],\n      moisture: f32[base + 2],\n      biome: u32[base + 3] as TerrainBiomeId,\n    });\n  }\n  return cells;\n}\n","declare const __PLASIUS_IMPORT_META_URL__: string;\n\nconst wgslBaseUrl =\n  typeof __PLASIUS_IMPORT_META_URL__ === \"string\" && __PLASIUS_IMPORT_META_URL__\n    ? __PLASIUS_IMPORT_META_URL__\n    : typeof document !== \"undefined\" && document.baseURI\n      ? document.baseURI\n      : typeof location !== \"undefined\"\n        ? location.href\n        : \"file:///\";\n\nexport const terrainWgslUrl = new URL(\"./terrain.wgsl\", wgslBaseUrl);\nexport const fieldWgslUrl = new URL(\"./field.wgsl\", wgslBaseUrl);\nexport const fractalPrepassWgslUrl = new URL(\"./fractal-prepass.wgsl\", wgslBaseUrl);\n\nexport async function loadTerrainWgsl(options: {\n  url?: URL | string;\n  fetcher?: typeof fetch | null;\n} = {}) {\n  const { url = terrainWgslUrl, fetcher = globalThis.fetch } = options;\n  const resolved = url instanceof URL ? url : new URL(url, terrainWgslUrl);\n\n  if (!fetcher || resolved.protocol === \"file:\") {\n    const { readFile } = await import(\"node:fs/promises\");\n    const { fileURLToPath } = await import(\"node:url\");\n    return readFile(fileURLToPath(resolved), \"utf8\");\n  }\n\n  const response = await fetcher(resolved);\n  if (!response.ok) {\n    const statusText = response.statusText ? ` ${response.statusText}` : \"\";\n    throw new Error(`Failed to load WGSL (${response.status}${statusText})`);\n  }\n  return response.text();\n}\n\nexport async function loadFieldWgsl(options: {\n  url?: URL | string;\n  fetcher?: typeof fetch | null;\n} = {}) {\n  const { url = fieldWgslUrl, fetcher = globalThis.fetch } = options;\n  const resolved = url instanceof URL ? url : new URL(url, fieldWgslUrl);\n\n  if (!fetcher || resolved.protocol === \"file:\") {\n    const { readFile } = await import(\"node:fs/promises\");\n    const { fileURLToPath } = await import(\"node:url\");\n    return readFile(fileURLToPath(resolved), \"utf8\");\n  }\n\n  const response = await fetcher(resolved);\n  if (!response.ok) {\n    const statusText = response.statusText ? ` ${response.statusText}` : \"\";\n    throw new Error(`Failed to load WGSL (${response.status}${statusText})`);\n  }\n  return response.text();\n}\n\nexport async function loadFractalPrepassWgsl(options: {\n  url?: URL | string;\n  fetcher?: typeof fetch | null;\n} = {}) {\n  const { url = fractalPrepassWgslUrl, fetcher = globalThis.fetch } = options;\n  const resolved = url instanceof URL ? url : new URL(url, fractalPrepassWgslUrl);\n\n  if (!fetcher || resolved.protocol === \"file:\") {\n    const { readFile } = await import(\"node:fs/promises\");\n    const { fileURLToPath } = await import(\"node:url\");\n    return readFile(fileURLToPath(resolved), \"utf8\");\n  }\n\n  const response = await fetcher(resolved);\n  if (!response.ok) {\n    const statusText = response.statusText ? ` ${response.statusText}` : \"\";\n    throw new Error(`Failed to load WGSL (${response.status}${statusText})`);\n  }\n  return response.text();\n}\n","export type FieldParams = {\n  seed: number;\n  scale: number;\n  warpScale: number;\n  warpStrength: number;\n  iterations: number;\n  power: number;\n  detailScale: number;\n  detailIterations: number;\n  detailPower: number;\n  ridgePower: number;\n  heatBias: number;\n  moistureBias: number;\n  macroScale: number;\n  macroWarpStrength: number;\n  styleMixStrength: number;\n  terraceSteps: number;\n  terraceStrength: number;\n  craterStrength: number;\n  craterScale: number;\n  heightMin: number;\n  heightMax: number;\n};\n\nexport type FieldSample = {\n  height: number;\n  heat: number;\n  moisture: number;\n  roughness: number;\n  rockiness: number;\n  water: number;\n  ridge: number;\n  base: number;\n  detail: number;\n};\n\nexport function defaultFieldParams(seed = 1337): FieldParams {\n  return {\n    seed,\n    scale: 0.14,\n    warpScale: 0.5,\n    warpStrength: 0.75,\n    iterations: 64,\n    power: 2.2,\n    detailScale: 3.2,\n    detailIterations: 28,\n    detailPower: 2.0,\n    ridgePower: 1.25,\n    heatBias: 0,\n    moistureBias: 0,\n    macroScale: 0.035,\n    macroWarpStrength: 0.18,\n    styleMixStrength: 1.0,\n    terraceSteps: 6,\n    terraceStrength: 0.35,\n    craterStrength: 0.25,\n    craterScale: 0.18,\n    heightMin: -0.35,\n    heightMax: 1.6,\n  };\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, value));\n}\n\nfunction smoothstep(edge0: number, edge1: number, x: number) {\n  const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);\n  return t * t * (3 - 2 * t);\n}\n\nfunction hash01(seed: number) {\n  const s = Math.sin(seed) * 43758.5453123;\n  return s - Math.floor(s);\n}\n\nfunction smoothMandelbrot(cx: number, cy: number, iterations: number, power: number) {\n  let zx = 0;\n  let zy = 0;\n  let i = 0;\n  for (; i < iterations; i += 1) {\n    const r2 = zx * zx + zy * zy;\n    if (r2 > 4) {\n      break;\n    }\n    const r = Math.sqrt(r2);\n    const theta = Math.atan2(zy, zx);\n    const rp = Math.pow(r, power);\n    zx = rp * Math.cos(theta * power) + cx;\n    zy = rp * Math.sin(theta * power) + cy;\n  }\n  if (i >= iterations) {\n    return 1;\n  }\n  const r = Math.max(Math.sqrt(zx * zx + zy * zy), 1e-6);\n  const nu = Math.log2(Math.log(r));\n  const smooth = (i + 1 - nu) / iterations;\n  return clamp(smooth, 0, 1);\n}\n\nfunction terrace(height: number, steps: number) {\n  const count = Math.max(1, Math.round(steps));\n  const step = 1 / count;\n  const h = clamp(height, 0, 1);\n  const band = Math.floor(h / step);\n  const t = (h - band * step) / step;\n  const smoothed = t * t * (3 - 2 * t);\n  return (band + smoothed) * step;\n}\n\nfunction craterField(x: number, z: number, scale: number, seed: number) {\n  const sx = x * scale;\n  const sz = z * scale;\n  const cellX = Math.floor(sx);\n  const cellZ = Math.floor(sz);\n  const fx = sx - cellX;\n  const fz = sz - cellZ;\n  const baseSeed = cellX * 374761393 + cellZ * 668265263 + seed * 1442695041;\n  const h0 = hash01(baseSeed * 0.17);\n  const h1 = hash01(baseSeed * 0.31 + 17.13);\n  const h2 = hash01(baseSeed * 0.47 + 9.2);\n  const cx = h0;\n  const cz = h1;\n  const radius = 0.22 + 0.25 * h2;\n  const dx = fx - cx;\n  const dz = fz - cz;\n  const dist = Math.hypot(dx, dz);\n  return smoothstep(radius, radius * 0.35, dist);\n}\n\nexport function sampleFieldStack(x: number, z: number, params: FieldParams): FieldSample {\n  const seed = params.seed;\n  const offX = hash01(seed * 0.137 + 0.11) * 4 - 2;\n  const offZ = hash01(seed * 0.173 + 0.27) * 4 - 2;\n  const warpOffX = hash01(seed * 0.91 + 1.1) * 6 - 3;\n  const warpOffZ = hash01(seed * 1.07 + 2.2) * 6 - 3;\n\n  const warpA = smoothMandelbrot(\n    (x + warpOffX) * params.warpScale,\n    (z + warpOffZ) * params.warpScale,\n    Math.max(16, Math.floor(params.iterations * 0.6)),\n    params.power\n  );\n  const warpB = smoothMandelbrot(\n    (x - warpOffZ) * params.warpScale,\n    (z + warpOffX) * params.warpScale,\n    Math.max(16, Math.floor(params.iterations * 0.6)),\n    params.power\n  );\n\n  const warpedX = x + (warpA - 0.5) * params.warpStrength;\n  const warpedZ = z + (warpB - 0.5) * params.warpStrength;\n\n  const base = smoothMandelbrot(\n    warpedX * params.scale + offX,\n    warpedZ * params.scale + offZ,\n    params.iterations,\n    params.power\n  );\n  const mid = smoothMandelbrot(\n    warpedX * params.scale * 2.15 + offX * 0.6,\n    warpedZ * params.scale * 2.15 + offZ * 0.6,\n    Math.max(18, Math.floor(params.iterations * 0.7)),\n    params.power + 0.2\n  );\n  const detail = smoothMandelbrot(\n    warpedX * params.scale * params.detailScale + offX * 1.4,\n    warpedZ * params.scale * params.detailScale + offZ * 1.4,\n    params.detailIterations,\n    params.detailPower\n  );\n\n  const ridge = 1 - Math.abs(2 * mid - 1);\n  const baseHeight =\n    Math.pow(base, 0.9) * Math.pow(mid, 1.05) * Math.pow(detail, 1.1);\n\n  const macroIter = Math.max(12, Math.floor(params.iterations * 0.35));\n  const macroA = smoothMandelbrot(\n    x * params.macroScale + offX * 0.2,\n    z * params.macroScale + offZ * 0.2,\n    macroIter,\n    params.power\n  );\n  const macroB = smoothMandelbrot(\n    (x + offZ) * params.macroScale,\n    (z - offX) * params.macroScale,\n    macroIter,\n    params.power + 0.35\n  );\n  const macroWarpX = (macroA - 0.5) * params.macroWarpStrength;\n  const macroWarpZ = (macroB - 0.5) * params.macroWarpStrength;\n  const macroMask = smoothMandelbrot(\n    (x + macroWarpX) * params.macroScale,\n    (z + macroWarpZ) * params.macroScale,\n    macroIter,\n    params.power\n  );\n  const styleMask = clamp((macroMask - 0.5) * params.styleMixStrength + 0.5, 0, 1);\n\n  const terraceHeight = terrace(baseHeight, params.terraceSteps);\n  const crater = craterField(x, z, params.craterScale, seed);\n  const styleA = clamp(Math.pow(baseHeight, 0.8) + Math.pow(ridge, 1.4) * 0.2, 0, 1);\n  const styleB = clamp(\n    baseHeight * (1 - params.terraceStrength) +\n      terraceHeight * params.terraceStrength -\n      crater * params.craterStrength +\n      Math.pow(ridge, 1.6) * 0.12,\n    0,\n    1\n  );\n  const mixed = styleA * (1 - styleMask) + styleB * styleMask;\n  const ridgeBoost = Math.pow(ridge, 1.35) * 0.22;\n  const centered = (mixed - 0.5) * 2;\n  const shaped = Math.sign(centered) * Math.pow(Math.abs(centered), 0.75);\n  const macroOffset = (styleMask - 0.5) * 0.25;\n  const rawHeight = clamp(\n    0.5 + shaped * 0.8 + macroOffset + ridgeBoost,\n    params.heightMin,\n    params.heightMax\n  );\n  const height01 = clamp(rawHeight, 0, 1);\n\n  const roughness = clamp(\n    Math.pow(ridge, params.ridgePower) * 0.7 + detail * 0.3,\n    0,\n    1\n  );\n  const heat = clamp(0.55 * mid + 0.35 * (1 - height01) + params.heatBias, 0, 1);\n  const moisture = clamp(\n    0.55 * detail +\n      0.35 * (1 - height01) -\n      (heat - 0.5) * 0.1 +\n      params.moistureBias,\n    0,\n    1\n  );\n  const rockiness = clamp(roughness * 0.6 + height01 * 0.4, 0, 1);\n  const water = clamp((0.32 - height01) * 3.0 + (moisture - 0.5) * 0.2, 0, 1);\n\n  return { height: rawHeight, heat, moisture, roughness, rockiness, water, ridge, base, detail };\n}\n","import { buildHexLevels, generateHexGrid } from \"../hex\";\nimport {\n  MacroBiome,\n  MicroFeature,\n  SurfaceCover,\n  TerrainBiome,\n  type HexCell,\n  type HexLevelSpec,\n  type TerrainCell,\n  type MicroFeatureId,\n  type SurfaceCoverId,\n} from \"../types\";\n\nexport interface MixedForestOptions {\n  seed: number;\n  radius?: number;\n  topAreaKm2?: number;\n  minAreaM2?: number;\n  levels?: number;\n}\n\nexport interface MixedForestLayer {\n  levelSpec: HexLevelSpec;\n  cells: HexCell[];\n  terrain: TerrainCell[];\n}\n\nfunction hash32(x: number): number {\n  let v = x >>> 0;\n  v ^= v >>> 17;\n  v = Math.imul(v, 0xed5ad4bb);\n  v ^= v >>> 11;\n  v = Math.imul(v, 0xac4c1b51);\n  v ^= v >>> 15;\n  v = Math.imul(v, 0x31848bab);\n  v ^= v >>> 14;\n  return v >>> 0;\n}\n\nfunction hash01(x: number): number {\n  return (hash32(x) & 0x00ffffff) / 16777216;\n}\n\nfunction hashCell(cell: HexCell, seed: number, salt: number): number {\n  const q = cell.q | 0;\n  const r = cell.r | 0;\n  const level = cell.level | 0;\n  const mixed =\n    (Math.imul(q, 1664525) ^ Math.imul(r, 1013904223) ^ Math.imul(level, 747796405) ^ seed ^ salt) >>>\n    0;\n  return hash01(mixed);\n}\n\nfunction clamp01(value: number): number {\n  return Math.min(1, Math.max(0, value));\n}\n\nfunction selectSurface(height: number, moisture: number, noise: number): SurfaceCoverId {\n  if (height < 0.12) {\n    return SurfaceCover.Water;\n  }\n  if (height > 0.72) {\n    return SurfaceCover.Rock;\n  }\n  if (moisture > 0.72) {\n    return SurfaceCover.Mud;\n  }\n  if (moisture > 0.5) {\n    return noise > 0.2 ? SurfaceCover.Grass : SurfaceCover.Dirt;\n  }\n  return noise > 0.6 ? SurfaceCover.Gravel : SurfaceCover.Dirt;\n}\n\nfunction selectFeature(\n  surface: SurfaceCoverId,\n  height: number,\n  moisture: number,\n  noise: number\n): MicroFeatureId | undefined {\n  if (surface === SurfaceCover.Water) {\n    return MicroFeature.WaterRipple;\n  }\n  if (surface === SurfaceCover.Rock || surface === SurfaceCover.Gravel) {\n    return noise > 0.7 ? MicroFeature.Boulder : MicroFeature.Rock;\n  }\n  if (moisture > 0.45 && noise > 0.25) {\n    return MicroFeature.Tree;\n  }\n  if (moisture > 0.4 && noise > 0.15) {\n    return MicroFeature.Bush;\n  }\n  if (surface === SurfaceCover.Grass && noise > 0.1) {\n    return MicroFeature.GrassTuft;\n  }\n  if (height > 0.6 && noise > 0.8) {\n    return MicroFeature.Rock;\n  }\n  return undefined;\n}\n\nexport function generateTemperateMixedForest(options: MixedForestOptions): MixedForestLayer {\n  const seed = options.seed >>> 0;\n  const levelSpecs = buildHexLevels({\n    topAreaKm2: options.topAreaKm2 ?? 1000,\n    minAreaM2: options.minAreaM2 ?? 10,\n    levels: options.levels ?? 6,\n  });\n  const levelSpec = levelSpecs[levelSpecs.length - 1];\n  const radius = options.radius ?? 6;\n  const cells = generateHexGrid(radius, levelSpec.level);\n\n  const terrain = cells.map((cell) => {\n    const base = hashCell(cell, seed, 0x1234);\n    const heatNoise = hashCell(cell, seed, 0x5345);\n    const moistureNoise = hashCell(cell, seed, 0x9c9c);\n    const featureNoise = hashCell(cell, seed, 0x77ab);\n\n    const height = clamp01(Math.pow(base, 1.1));\n    const heat = clamp01(0.45 + (heatNoise - 0.5) * 0.25 - height * 0.12);\n    const moisture = clamp01(0.55 + (moistureNoise - 0.5) * 0.35 - height * 0.05);\n\n    const surface = selectSurface(height, moisture, featureNoise);\n    const feature = selectFeature(surface, height, moisture, featureNoise);\n\n    const cellData: TerrainCell = {\n      height,\n      heat,\n      moisture,\n      biome: TerrainBiome.MixedForest,\n      macroBiome: MacroBiome.Temperate,\n      surface,\n      feature,\n    };\n\n    return cellData;\n  });\n\n  return { levelSpec, cells, terrain };\n}\n","export interface PerfMonitorOptions {\n  targetFps?: number;\n  tolerance?: number;\n  sampleSize?: number;\n  minSampleFraction?: number;\n  cooldownMs?: number;\n  qualitySlew?: number;\n  initialBudget?: number;\n  auto?: boolean;\n}\n\nexport interface PerfMonitorUpdate {\n  budget: number;\n  medianFps: number | null;\n  miss: number | null;\n  adjusted: boolean;\n  stable: boolean;\n}\n\nexport interface PerfMonitor {\n  sampleFrame: (dtSeconds: number) => void;\n  sampleFps: (fps: number) => void;\n  update: (nowMs: number) => PerfMonitorUpdate;\n  resetSamples: () => void;\n  setBudget: (budget: number) => void;\n  getBudget: () => number;\n  setAuto: (enabled: boolean) => void;\n  getConfig: () => Required<PerfMonitorOptions>;\n}\n\nconst defaultOptions: Required<PerfMonitorOptions> = {\n  targetFps: 120,\n  tolerance: 6,\n  sampleSize: 90,\n  minSampleFraction: 0.6,\n  cooldownMs: 1200,\n  qualitySlew: 0.05,\n  initialBudget: 0.5,\n  auto: true,\n};\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, value));\n}\n\nfunction clamp01(value: number) {\n  return clamp(value, 0, 1);\n}\n\nfunction median(values: number[]) {\n  if (!values.length) return 0;\n  const sorted = values.slice().sort((a, b) => a - b);\n  const mid = Math.floor(sorted.length / 2);\n  if (sorted.length % 2 === 0) {\n    return (sorted[mid - 1] + sorted[mid]) * 0.5;\n  }\n  return sorted[mid];\n}\n\nexport function createPerfMonitor(options: PerfMonitorOptions = {}): PerfMonitor {\n  const config: Required<PerfMonitorOptions> = { ...defaultOptions, ...options };\n  let budget = clamp01(config.initialBudget);\n  let lastAdjust = 0;\n  const samples: number[] = [];\n\n  const sampleFps = (fps: number) => {\n    if (!Number.isFinite(fps) || fps <= 0) return;\n    samples.push(fps);\n    if (samples.length > config.sampleSize) {\n      samples.shift();\n    }\n  };\n\n  const sampleFrame = (dtSeconds: number) => {\n    if (!Number.isFinite(dtSeconds) || dtSeconds <= 0) return;\n    sampleFps(1 / dtSeconds);\n  };\n\n  const update = (nowMs: number): PerfMonitorUpdate => {\n    if (!config.auto) {\n      return { budget, medianFps: null, miss: null, adjusted: false, stable: true };\n    }\n    if (nowMs - lastAdjust < config.cooldownMs) {\n      return { budget, medianFps: null, miss: null, adjusted: false, stable: false };\n    }\n    if (samples.length < Math.floor(config.sampleSize * config.minSampleFraction)) {\n      return { budget, medianFps: null, miss: null, adjusted: false, stable: false };\n    }\n\n    const med = median(samples);\n    const miss = config.targetFps - med;\n    const tol = config.tolerance;\n    if (Math.abs(miss) <= tol) {\n      lastAdjust = nowMs;\n      return { budget, medianFps: med, miss, adjusted: false, stable: true };\n    }\n\n    const magnitude = Math.min(1, (Math.abs(miss) - tol) / tol);\n    const direction = miss > 0 ? -1 : 1;\n    const next = clamp01(budget + direction * magnitude * config.qualitySlew);\n    const adjusted = next !== budget;\n    budget = next;\n    lastAdjust = nowMs;\n    return { budget, medianFps: med, miss, adjusted, stable: false };\n  };\n\n  const resetSamples = () => {\n    samples.length = 0;\n  };\n\n  const setBudget = (next: number) => {\n    budget = clamp01(next);\n  };\n\n  const getBudget = () => budget;\n\n  const setAuto = (enabled: boolean) => {\n    config.auto = enabled;\n  };\n\n  const getConfig = () => ({ ...config });\n\n  return {\n    sampleFrame,\n    sampleFps,\n    update,\n    resetSamples,\n    setBudget,\n    getBudget,\n    setAuto,\n    getConfig,\n  };\n}\n","import { defaultFieldParams, type FieldParams } from \"./fields\";\n\nconst GPUBufferUsage = (globalThis as any).GPUBufferUsage;\nconst GPUMapMode = (globalThis as any).GPUMapMode;\n\ntype GPUDeviceLike = any;\n\nexport const FRACTAL_ASSET_VERSION = 2;\nexport const FRACTAL_SAMPLE_STRIDE = 8;\n\nexport type FractalMandelSettings = {\n  scale: number;\n  strength: number;\n  rockBoost: number;\n};\n\nexport const defaultFractalMandelSettings: FractalMandelSettings = {\n  scale: 0.16,\n  strength: 0.85,\n  rockBoost: 0.7,\n};\n\nexport type FractalAsset = {\n  seed: number;\n  extent: number;\n  gridSize: number;\n  heightScale: number;\n  samples: Float32Array;\n};\n\nexport type FractalAssetPayload = {\n  version: number;\n  seed: number;\n  extent: number;\n  gridSize: number;\n  heightScale: number;\n  sampleStride: number;\n  samples: number[];\n};\n\nexport type FractalPrepassRunOptions = {\n  seed: number;\n  extent: number;\n  heightScale: number;\n  fieldParams?: Partial<FieldParams>;\n  mandel?: Partial<FractalMandelSettings>;\n};\n\nexport type FractalPrepassRunner = {\n  gridSize: number;\n  gridPoints: number;\n  sampleCount: number;\n  run: (options: FractalPrepassRunOptions) => Promise<FractalAsset>;\n};\n\nexport function serializeFractalAsset(asset: FractalAsset): FractalAssetPayload {\n  return {\n    version: FRACTAL_ASSET_VERSION,\n    seed: asset.seed,\n    extent: asset.extent,\n    gridSize: asset.gridSize,\n    heightScale: asset.heightScale,\n    sampleStride: FRACTAL_SAMPLE_STRIDE,\n    samples: Array.from(asset.samples),\n  };\n}\n\nexport function parseFractalAsset(payload: unknown): FractalAsset | null {\n  if (!payload || typeof payload !== \"object\") return null;\n  const data = payload as FractalAssetPayload;\n  if (data.version !== FRACTAL_ASSET_VERSION) return null;\n  if (!Array.isArray(data.samples)) return null;\n  if (data.sampleStride !== FRACTAL_SAMPLE_STRIDE) return null;\n  const gridSize = Number(data.gridSize);\n  const heightScale = Number(data.heightScale);\n  if (!Number.isFinite(gridSize) || gridSize <= 0) return null;\n  if (!Number.isFinite(heightScale)) return null;\n  const expected = (gridSize + 1) * (gridSize + 1) * FRACTAL_SAMPLE_STRIDE;\n  if (data.samples.length !== expected) return null;\n  return {\n    seed: Number(data.seed),\n    extent: Number(data.extent),\n    gridSize,\n    heightScale,\n    samples: new Float32Array(data.samples),\n  };\n}\n\nexport function assetMatches(\n  asset: FractalAsset | null,\n  config: { seed: number; extent: number; gridSize: number }\n) {\n  if (!asset) return false;\n  if (asset.seed !== config.seed) return false;\n  if (asset.gridSize !== config.gridSize) return false;\n  if (Math.abs(asset.extent - config.extent) > 1e-3) return false;\n  if (!Number.isFinite(asset.heightScale)) return false;\n  const expected = (asset.gridSize + 1) * (asset.gridSize + 1) * FRACTAL_SAMPLE_STRIDE;\n  if (asset.samples.length !== expected) return false;\n  return true;\n}\n\nexport function createFractalPrepassRunner(options: {\n  device: GPUDeviceLike;\n  wgsl: string;\n  gridSize: number;\n}): FractalPrepassRunner {\n  if (!GPUBufferUsage || !GPUMapMode) {\n    throw new Error(\"WebGPU globals not available. Ensure this runs in a WebGPU context.\");\n  }\n  const { device, wgsl, gridSize } = options;\n  const gridPoints = gridSize + 1;\n  const sampleCount = gridPoints * gridPoints;\n  const byteSize = sampleCount * FRACTAL_SAMPLE_STRIDE * 4;\n\n  const uniformBuffer = device.createBuffer({\n    size: 7 * 16,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  const baseBuffer = device.createBuffer({\n    size: byteSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  const accentBuffer = device.createBuffer({\n    size: byteSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  const readbackBuffer = device.createBuffer({\n    size: byteSize,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n  });\n\n  const module = device.createShaderModule({ code: wgsl });\n  const basePipeline = device.createComputePipeline({\n    layout: \"auto\",\n    compute: { module, entryPoint: \"main\" },\n  });\n  const accentPipeline = device.createComputePipeline({\n    layout: \"auto\",\n    compute: { module, entryPoint: \"accent_heights\" },\n  });\n\n  const baseBindGroup = device.createBindGroup({\n    layout: basePipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: uniformBuffer } },\n      { binding: 1, resource: { buffer: baseBuffer } },\n    ],\n  });\n  const accentBindGroup = device.createBindGroup({\n    layout: accentPipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: uniformBuffer } },\n      { binding: 1, resource: { buffer: accentBuffer } },\n      { binding: 2, resource: { buffer: baseBuffer } },\n    ],\n  });\n\n  const workgroups = Math.ceil(gridPoints / 8);\n\n  const run = async (runOptions: FractalPrepassRunOptions): Promise<FractalAsset> => {\n    const fieldDefaults = defaultFieldParams(runOptions.seed);\n    const params: FieldParams = {\n      ...fieldDefaults,\n      ...runOptions.fieldParams,\n      seed: runOptions.seed,\n    };\n    const mandel = { ...defaultFractalMandelSettings, ...runOptions.mandel };\n    const step = (runOptions.extent * 2) / gridSize;\n\n    const uniformData = new Float32Array(28);\n    uniformData.set([gridPoints, runOptions.extent, step, runOptions.seed], 0);\n    uniformData.set(\n      [params.scale, params.warpScale, params.warpStrength, params.power],\n      4\n    );\n    uniformData.set(\n      [params.detailScale, params.detailPower, params.ridgePower, params.heatBias],\n      8\n    );\n    uniformData.set(\n      [params.moistureBias, mandel.scale, mandel.strength, mandel.rockBoost],\n      12\n    );\n    uniformData.set(\n      [params.iterations, params.detailIterations, params.macroScale, params.macroWarpStrength],\n      16\n    );\n    uniformData.set(\n      [\n        params.styleMixStrength,\n        params.terraceSteps,\n        params.terraceStrength,\n        params.craterStrength,\n      ],\n      20\n    );\n    uniformData.set([params.craterScale, params.heightMin, params.heightMax, 0], 24);\n\n    device.queue.writeBuffer(uniformBuffer, 0, uniformData);\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(basePipeline);\n    pass.setBindGroup(0, baseBindGroup);\n    pass.dispatchWorkgroups(workgroups, workgroups);\n    pass.setPipeline(accentPipeline);\n    pass.setBindGroup(0, accentBindGroup);\n    pass.dispatchWorkgroups(workgroups, workgroups);\n    pass.end();\n    encoder.copyBufferToBuffer(accentBuffer, 0, readbackBuffer, 0, byteSize);\n    device.queue.submit([encoder.finish()]);\n\n    await readbackBuffer.mapAsync(GPUMapMode.READ);\n    const copy = readbackBuffer.getMappedRange();\n    const data = new Float32Array(copy.slice(0));\n    readbackBuffer.unmap();\n\n    return {\n      seed: runOptions.seed,\n      extent: runOptions.extent,\n      gridSize,\n      heightScale: runOptions.heightScale,\n      samples: data,\n    };\n  };\n\n  return {\n    gridSize,\n    gridPoints,\n    sampleCount,\n    run,\n  };\n}\n","export type TileKey = {\n  seed: number;\n  tx: number;\n  tz: number;\n  level: number;\n  tileSizeWorld?: number;\n};\n\nexport interface TileAsset {\n  key: TileKey;\n  gridSize: number;\n  heightScale: number;\n  height: Float32Array;\n  fields?: Float32Array;\n  fieldStride?: number;\n  materials?: Uint8Array;\n  materialStride?: number;\n  features?: Float32Array;\n  featureStride?: number;\n}\n\nexport interface TileAssetPayload {\n  version: number;\n  key: TileKey;\n  gridSize: number;\n  heightScale: number;\n  height: number[];\n  fields?: number[];\n  fieldStride?: number;\n  materials?: number[];\n  materialStride?: number;\n  features?: number[];\n  featureStride?: number;\n}\n\nexport const TILE_ASSET_VERSION = 1;\n\nconst MAGIC_BYTES = [0x54, 0x57, 0x4c, 0x44]; // \"TWLD\"\nconst HEADER_BYTES = 68;\n\nconst FLAG_HAS_TILE_SIZE = 1 << 0;\nconst FLAG_HAS_FIELDS = 1 << 1;\nconst FLAG_HAS_MATERIALS = 1 << 2;\nconst FLAG_HAS_FEATURES = 1 << 3;\n\nfunction align4(offset: number) {\n  return (offset + 3) & ~3;\n}\n\nfunction expectedHeightCount(gridSize: number) {\n  const gridPoints = gridSize + 1;\n  return gridPoints * gridPoints;\n}\n\nexport function validateTileAssetPayload(payload: TileAssetPayload): string[] {\n  const errors: string[] = [];\n  if (!payload || typeof payload !== \"object\") {\n    return [\"payload must be an object\"];\n  }\n  const key = payload.key as TileKey;\n  if (!key || typeof key !== \"object\") {\n    errors.push(\"key is required\");\n  } else {\n    const keyFields: Array<keyof TileKey> = [\"seed\", \"tx\", \"tz\", \"level\"];\n    for (const field of keyFields) {\n      const value = key[field];\n      if (!Number.isFinite(value)) {\n        errors.push(`key.${field} must be a number`);\n      }\n    }\n    if (key.tileSizeWorld !== undefined && !Number.isFinite(key.tileSizeWorld)) {\n      errors.push(\"key.tileSizeWorld must be a number when provided\");\n    }\n  }\n\n  if (!Number.isFinite(payload.gridSize) || payload.gridSize < 1) {\n    errors.push(\"gridSize must be a positive number\");\n  }\n  if (!Number.isFinite(payload.heightScale)) {\n    errors.push(\"heightScale must be a number\");\n  }\n  if (!Array.isArray(payload.height)) {\n    errors.push(\"height must be an array\");\n  } else {\n    const expected = expectedHeightCount(payload.gridSize);\n    if (payload.height.length !== expected) {\n      errors.push(`height length must be ${expected} for gridSize ${payload.gridSize}`);\n    }\n  }\n\n  const materialStride =\n    payload.materialStride ?? (payload.materials ? 1 : 0);\n  if (payload.materials) {\n    if (!Number.isFinite(materialStride) || materialStride <= 0) {\n      errors.push(\"materialStride must be > 0 when materials are provided\");\n    } else if (payload.materials.length % materialStride !== 0) {\n      errors.push(\"materials length must be divisible by materialStride\");\n    }\n  }\n\n  if (payload.fields) {\n    if (!Number.isFinite(payload.fieldStride) || (payload.fieldStride ?? 0) <= 0) {\n      errors.push(\"fieldStride must be > 0 when fields are provided\");\n    } else if (payload.fields.length % payload.fieldStride! !== 0) {\n      errors.push(\"fields length must be divisible by fieldStride\");\n    }\n  }\n\n  if (payload.features) {\n    if (!Number.isFinite(payload.featureStride) || (payload.featureStride ?? 0) <= 0) {\n      errors.push(\"featureStride must be > 0 when features are provided\");\n    } else if (payload.features.length % payload.featureStride! !== 0) {\n      errors.push(\"features length must be divisible by featureStride\");\n    }\n  }\n\n  return errors;\n}\n\nexport function serializeTileAssetJson(asset: TileAsset): TileAssetPayload {\n  return {\n    version: TILE_ASSET_VERSION,\n    key: asset.key,\n    gridSize: asset.gridSize,\n    heightScale: asset.heightScale,\n    height: Array.from(asset.height),\n    fields: asset.fields ? Array.from(asset.fields) : undefined,\n    fieldStride: asset.fieldStride,\n    materials: asset.materials ? Array.from(asset.materials) : undefined,\n    materialStride: asset.materialStride ?? (asset.materials ? 1 : undefined),\n    features: asset.features ? Array.from(asset.features) : undefined,\n    featureStride: asset.featureStride,\n  };\n}\n\nexport function parseTileAssetJson(payload: TileAssetPayload): TileAsset {\n  const errors = validateTileAssetPayload(payload);\n  if (errors.length) {\n    throw new Error(`Invalid tile asset payload: ${errors.join(\"; \")}`);\n  }\n\n  const materialStride =\n    payload.materialStride ?? (payload.materials ? 1 : undefined);\n\n  return {\n    key: payload.key,\n    gridSize: payload.gridSize,\n    heightScale: payload.heightScale,\n    height: Float32Array.from(payload.height),\n    fields: payload.fields ? Float32Array.from(payload.fields) : undefined,\n    fieldStride: payload.fieldStride,\n    materials: payload.materials ? Uint8Array.from(payload.materials) : undefined,\n    materialStride,\n    features: payload.features ? Float32Array.from(payload.features) : undefined,\n    featureStride: payload.featureStride,\n  };\n}\n\nexport interface TileBakeOutput {\n  asset: TileAsset;\n  payload: TileAssetPayload;\n  binary: ArrayBuffer;\n}\n\nexport interface TileBakeWriter {\n  writeJson?: (payload: TileAssetPayload, asset: TileAsset) => void | Promise<void>;\n  writeBinary?: (\n    binary: ArrayBuffer,\n    asset: TileAsset,\n    payload: TileAssetPayload\n  ) => void | Promise<void>;\n}\n\nexport async function bakeTileAsset(\n  asset: TileAsset,\n  writer?: TileBakeWriter\n): Promise<TileBakeOutput> {\n  const payload = serializeTileAssetJson(asset);\n  const errors = validateTileAssetPayload(payload);\n  if (errors.length) {\n    throw new Error(`Invalid tile asset payload: ${errors.join(\"; \")}`);\n  }\n  if (writer?.writeJson) {\n    await writer.writeJson(payload, asset);\n  }\n  const binary = serializeTileAssetBinaryFromJson(payload);\n  if (writer?.writeBinary) {\n    await writer.writeBinary(binary, asset, payload);\n  }\n  return { asset, payload, binary };\n}\n\nexport function serializeTileAssetBinary(asset: TileAsset): ArrayBuffer {\n  const heightCount = asset.height.length;\n  const expected = expectedHeightCount(asset.gridSize);\n  if (heightCount !== expected) {\n    throw new Error(`height length must be ${expected} for gridSize ${asset.gridSize}`);\n  }\n\n  const fieldStride = asset.fieldStride ?? 0;\n  if (asset.fields && fieldStride <= 0) {\n    throw new Error(\"fieldStride must be provided when fields exist\");\n  }\n  const materialStride = asset.materialStride ?? (asset.materials ? 1 : 0);\n  if (asset.materials && materialStride <= 0) {\n    throw new Error(\"materialStride must be provided when materials exist\");\n  }\n  const featureStride = asset.featureStride ?? 0;\n  if (asset.features && featureStride <= 0) {\n    throw new Error(\"featureStride must be provided when features exist\");\n  }\n\n  const fieldCount = asset.fields ? asset.fields.length : 0;\n  const materialCount = asset.materials ? asset.materials.length : 0;\n  const featureCount = asset.features ? asset.features.length : 0;\n\n  const heightBytes = heightCount * 4;\n  const fieldBytes = fieldCount * 4;\n  const materialBytes = materialCount;\n  const featureBytes = featureCount * 4;\n\n  let offset = HEADER_BYTES + heightBytes + fieldBytes + materialBytes;\n  offset = align4(offset);\n  const totalBytes = offset + featureBytes;\n\n  const buffer = new ArrayBuffer(totalBytes);\n  const view = new DataView(buffer);\n  const u8 = new Uint8Array(buffer);\n\n  u8.set(MAGIC_BYTES, 0);\n  let cursor = 4;\n\n  view.setUint32(cursor, TILE_ASSET_VERSION, true);\n  cursor += 4;\n\n  let flags = 0;\n  if (asset.key.tileSizeWorld !== undefined) flags |= FLAG_HAS_TILE_SIZE;\n  if (fieldCount) flags |= FLAG_HAS_FIELDS;\n  if (materialCount) flags |= FLAG_HAS_MATERIALS;\n  if (featureCount) flags |= FLAG_HAS_FEATURES;\n  view.setUint32(cursor, flags, true);\n  cursor += 4;\n\n  view.setInt32(cursor, asset.key.tx | 0, true);\n  cursor += 4;\n  view.setInt32(cursor, asset.key.tz | 0, true);\n  cursor += 4;\n  view.setUint32(cursor, asset.key.level >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, asset.key.seed >>> 0, true);\n  cursor += 4;\n  view.setFloat32(cursor, asset.key.tileSizeWorld ?? 0, true);\n  cursor += 4;\n\n  view.setUint32(cursor, asset.gridSize >>> 0, true);\n  cursor += 4;\n  view.setFloat32(cursor, asset.heightScale, true);\n  cursor += 4;\n\n  view.setUint32(cursor, heightCount >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, fieldCount >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, materialCount >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, featureCount >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, fieldStride >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, materialStride >>> 0, true);\n  cursor += 4;\n  view.setUint32(cursor, featureStride >>> 0, true);\n  cursor += 4;\n\n  let writeOffset = HEADER_BYTES;\n  new Float32Array(buffer, writeOffset, heightCount).set(asset.height);\n  writeOffset += heightBytes;\n\n  if (fieldCount) {\n    new Float32Array(buffer, writeOffset, fieldCount).set(asset.fields!);\n    writeOffset += fieldBytes;\n  }\n\n  if (materialCount) {\n    new Uint8Array(buffer, writeOffset, materialCount).set(asset.materials!);\n    writeOffset += materialBytes;\n  }\n\n  writeOffset = align4(writeOffset);\n\n  if (featureCount) {\n    new Float32Array(buffer, writeOffset, featureCount).set(asset.features!);\n  }\n\n  return buffer;\n}\n\nexport function parseTileAssetBinary(input: ArrayBuffer | ArrayBufferView): TileAsset {\n  const buffer =\n    input instanceof ArrayBuffer\n      ? input\n      : input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength);\n\n  if (buffer.byteLength < HEADER_BYTES) {\n    throw new Error(\"Buffer too small for tile asset header\");\n  }\n\n  const u8 = new Uint8Array(buffer);\n  for (let i = 0; i < MAGIC_BYTES.length; i += 1) {\n    if (u8[i] !== MAGIC_BYTES[i]) {\n      throw new Error(\"Invalid tile asset magic header\");\n    }\n  }\n\n  const view = new DataView(buffer);\n  let cursor = 4;\n  const version = view.getUint32(cursor, true);\n  cursor += 4;\n  if (version !== TILE_ASSET_VERSION) {\n    throw new Error(`Unsupported tile asset version ${version}`);\n  }\n\n  const flags = view.getUint32(cursor, true);\n  cursor += 4;\n  const tx = view.getInt32(cursor, true);\n  cursor += 4;\n  const tz = view.getInt32(cursor, true);\n  cursor += 4;\n  const level = view.getUint32(cursor, true);\n  cursor += 4;\n  const seed = view.getUint32(cursor, true);\n  cursor += 4;\n  const tileSizeWorld = view.getFloat32(cursor, true);\n  cursor += 4;\n\n  const gridSize = view.getUint32(cursor, true);\n  cursor += 4;\n  const heightScale = view.getFloat32(cursor, true);\n  cursor += 4;\n\n  const heightCount = view.getUint32(cursor, true);\n  cursor += 4;\n  const fieldCount = view.getUint32(cursor, true);\n  cursor += 4;\n  const materialCount = view.getUint32(cursor, true);\n  cursor += 4;\n  const featureCount = view.getUint32(cursor, true);\n  cursor += 4;\n  const fieldStride = view.getUint32(cursor, true);\n  cursor += 4;\n  const materialStride = view.getUint32(cursor, true);\n  cursor += 4;\n  const featureStride = view.getUint32(cursor, true);\n  cursor += 4;\n\n  const heightBytes = heightCount * 4;\n  const fieldBytes = fieldCount * 4;\n  const materialBytes = materialCount;\n  const featureBytes = featureCount * 4;\n  let required = HEADER_BYTES + heightBytes + fieldBytes + materialBytes;\n  required = align4(required) + featureBytes;\n  if (buffer.byteLength < required) {\n    throw new Error(\"Tile asset buffer is truncated\");\n  }\n\n  let readOffset = HEADER_BYTES;\n  const height = new Float32Array(buffer, readOffset, heightCount);\n  readOffset += heightCount * 4;\n\n  const fields = fieldCount\n    ? new Float32Array(buffer, readOffset, fieldCount)\n    : undefined;\n  readOffset += fieldCount * 4;\n\n  const materials = materialCount\n    ? new Uint8Array(buffer, readOffset, materialCount)\n    : undefined;\n  readOffset += materialCount;\n  readOffset = align4(readOffset);\n\n  const features = featureCount\n    ? new Float32Array(buffer, readOffset, featureCount)\n    : undefined;\n\n  const key: TileKey = {\n    seed,\n    tx,\n    tz,\n    level,\n  };\n  if (flags & FLAG_HAS_TILE_SIZE) {\n    key.tileSizeWorld = tileSizeWorld;\n  }\n\n  return {\n    key,\n    gridSize,\n    heightScale,\n    height,\n    fields,\n    fieldStride: fieldCount ? fieldStride : undefined,\n    materials,\n    materialStride: materialCount ? materialStride : undefined,\n    features,\n    featureStride: featureCount ? featureStride : undefined,\n  };\n}\n\nexport function serializeTileAssetBinaryFromJson(payload: TileAssetPayload): ArrayBuffer {\n  return serializeTileAssetBinary(parseTileAssetJson(payload));\n}\n\nexport function serializeTileAssetJsonFromBinary(\n  input: ArrayBuffer | ArrayBufferView\n): TileAssetPayload {\n  return serializeTileAssetJson(parseTileAssetBinary(input));\n}\n","import type { TileAsset, TileAssetPayload, TileBakeWriter, TileKey } from \"./tiles\";\nimport { bakeTileAsset } from \"./tiles\";\n\nexport type TileCacheStatus = \"pending\" | \"ready\" | \"error\";\n\nexport interface TileCacheEntry {\n  key: TileKey;\n  status: TileCacheStatus;\n  asset?: TileAsset;\n  payload?: TileAssetPayload;\n  binary?: ArrayBuffer;\n  bytes: number;\n  lastAccess: number;\n  error?: unknown;\n}\n\nexport type TileGenerator = (key: TileKey) => TileAsset | Promise<TileAsset>;\n\nexport interface TileCacheOptions {\n  maxEntries?: number;\n  maxBytes?: number;\n  keepBinary?: boolean;\n  keepJson?: boolean;\n  writer?: TileBakeWriter;\n  now?: () => number;\n  onEvict?: (entry: TileCacheEntry) => void;\n}\n\nexport const DEFAULT_TILE_SIZE_WORLD = 64;\n\nexport function normalizeTileKey(key: TileKey): TileKey {\n  const tileSizeWorld =\n    key.tileSizeWorld !== undefined && Number.isFinite(key.tileSizeWorld)\n      ? Number(key.tileSizeWorld)\n      : undefined;\n  return {\n    seed: key.seed >>> 0,\n    tx: Math.trunc(key.tx),\n    tz: Math.trunc(key.tz),\n    level: Math.max(0, Math.trunc(key.level)),\n    tileSizeWorld,\n  };\n}\n\nexport function tileKeyToString(key: TileKey): string {\n  const normalized = normalizeTileKey(key);\n  const tileSize =\n    normalized.tileSizeWorld === undefined\n      ? \"default\"\n      : normalized.tileSizeWorld.toFixed(3);\n  return [\n    normalized.seed,\n    normalized.level,\n    normalized.tx,\n    normalized.tz,\n    tileSize,\n  ].join(\":\");\n}\n\nexport function resolveTileSizeWorld(\n  key: TileKey,\n  defaultTileSizeWorld = DEFAULT_TILE_SIZE_WORLD\n) {\n  return key.tileSizeWorld ?? defaultTileSizeWorld;\n}\n\nexport function tileBoundsWorld(\n  key: TileKey,\n  defaultTileSizeWorld = DEFAULT_TILE_SIZE_WORLD\n) {\n  const size = resolveTileSizeWorld(key, defaultTileSizeWorld);\n  const minX = key.tx * size;\n  const minZ = key.tz * size;\n  return {\n    minX,\n    minZ,\n    maxX: minX + size,\n    maxZ: minZ + size,\n    centerX: minX + size * 0.5,\n    centerZ: minZ + size * 0.5,\n    size,\n  };\n}\n\nexport function tileKeyFromWorldPosition(options: {\n  seed: number;\n  x: number;\n  z: number;\n  level?: number;\n  tileSizeWorld?: number;\n  defaultTileSizeWorld?: number;\n}): TileKey {\n  const size =\n    options.tileSizeWorld ?? options.defaultTileSizeWorld ?? DEFAULT_TILE_SIZE_WORLD;\n  const tx = Math.floor(options.x / size);\n  const tz = Math.floor(options.z / size);\n  return {\n    seed: options.seed,\n    tx,\n    tz,\n    level: options.level ?? 0,\n    tileSizeWorld: options.tileSizeWorld,\n  };\n}\n\nexport function tileAssetFileStem(key: TileKey): string {\n  const normalized = normalizeTileKey(key);\n  const suffix =\n    normalized.tileSizeWorld === undefined\n      ? \"\"\n      : `-ts${normalized.tileSizeWorld.toFixed(3)}`;\n  return `tile-${normalized.seed}-${normalized.level}-${normalized.tx}-${normalized.tz}${suffix}`;\n}\n\nfunction estimateAssetBytes(asset: TileAsset, payload?: TileAssetPayload, binary?: ArrayBuffer) {\n  let bytes = asset.height.length * 4;\n  if (asset.fields) bytes += asset.fields.length * 4;\n  if (asset.materials) bytes += asset.materials.length;\n  if (asset.features) bytes += asset.features.length * 4;\n  if (binary) bytes += binary.byteLength;\n  if (payload) {\n    // Rough estimate of JSON footprint to help eviction logic.\n    bytes += payload.height.length * 4;\n  }\n  return bytes;\n}\n\nexport class TileCache {\n  private entries = new Map<string, TileCacheEntry>();\n  private inflight = new Map<string, Promise<TileCacheEntry>>();\n  private totalBytes = 0;\n  private options: Required<Omit<TileCacheOptions, \"writer\">> & {\n    writer?: TileBakeWriter;\n  };\n\n  constructor(options: TileCacheOptions = {}) {\n    this.options = {\n      maxEntries: options.maxEntries ?? 128,\n      maxBytes: options.maxBytes ?? 128 * 1024 * 1024,\n      keepBinary: options.keepBinary ?? true,\n      keepJson: options.keepJson ?? true,\n      writer: options.writer,\n      now: options.now ?? (() => Date.now()),\n      onEvict: options.onEvict ?? (() => {}),\n    };\n  }\n\n  getStats() {\n    return {\n      entries: this.entries.size,\n      bytes: this.totalBytes,\n      inflight: this.inflight.size,\n    };\n  }\n\n  has(key: TileKey) {\n    return this.entries.has(tileKeyToString(key));\n  }\n\n  get(key: TileKey): TileCacheEntry | undefined {\n    const id = tileKeyToString(key);\n    const entry = this.entries.get(id);\n    if (entry) {\n      entry.lastAccess = this.options.now();\n    }\n    return entry;\n  }\n\n  async getOrCreate(key: TileKey, generator: TileGenerator): Promise<TileCacheEntry> {\n    const normalized = normalizeTileKey(key);\n    const id = tileKeyToString(normalized);\n    const cached = this.entries.get(id);\n    if (cached && cached.status === \"ready\") {\n      cached.lastAccess = this.options.now();\n      return cached;\n    }\n    const inflight = this.inflight.get(id);\n    if (inflight) {\n      return inflight;\n    }\n\n    const entry: TileCacheEntry = {\n      key: normalized,\n      status: \"pending\",\n      bytes: 0,\n      lastAccess: this.options.now(),\n    };\n    this.entries.set(id, entry);\n\n    const promise = (async () => {\n      try {\n        const asset = await generator(normalized);\n        const baked = await bakeTileAsset(asset, this.options.writer);\n\n        const payload = this.options.keepJson ? baked.payload : undefined;\n        const binary = this.options.keepBinary ? baked.binary : undefined;\n        const bytes = estimateAssetBytes(asset, payload, binary);\n\n        const ready: TileCacheEntry = {\n          key: normalized,\n          status: \"ready\",\n          asset,\n          payload,\n          binary,\n          bytes,\n          lastAccess: this.options.now(),\n        };\n        this.replaceEntry(id, ready);\n        this.inflight.delete(id);\n        this.evictIfNeeded();\n        return ready;\n      } catch (error) {\n        const failed: TileCacheEntry = {\n          key: normalized,\n          status: \"error\",\n          bytes: 0,\n          lastAccess: this.options.now(),\n          error,\n        };\n        this.replaceEntry(id, failed);\n        this.inflight.delete(id);\n        return failed;\n      }\n    })();\n\n    this.inflight.set(id, promise);\n    return promise;\n  }\n\n  delete(key: TileKey) {\n    const id = tileKeyToString(key);\n    const entry = this.entries.get(id);\n    if (!entry) return false;\n    this.entries.delete(id);\n    this.totalBytes -= entry.bytes;\n    this.options.onEvict(entry);\n    return true;\n  }\n\n  private replaceEntry(id: string, entry: TileCacheEntry) {\n    const existing = this.entries.get(id);\n    if (existing) {\n      this.totalBytes -= existing.bytes;\n    }\n    this.entries.set(id, entry);\n    this.totalBytes += entry.bytes;\n  }\n\n  private evictIfNeeded() {\n    const { maxEntries, maxBytes } = this.options;\n    while (this.entries.size > maxEntries || this.totalBytes > maxBytes) {\n      let oldestId: string | null = null;\n      let oldestTime = Infinity;\n      for (const [id, entry] of this.entries) {\n        if (entry.status !== \"ready\") continue;\n        if (entry.lastAccess < oldestTime) {\n          oldestTime = entry.lastAccess;\n          oldestId = id;\n        }\n      }\n      if (!oldestId) {\n        break;\n      }\n      const entry = this.entries.get(oldestId);\n      if (entry) {\n        this.entries.delete(oldestId);\n        this.totalBytes -= entry.bytes;\n        this.options.onEvict(entry);\n      } else {\n        break;\n      }\n    }\n  }\n}\n","export type Vec3 = [number, number, number];\n\nexport type MeshGeomorph = {\n  targetY: number;\n  weight?: number;\n};\n\nexport interface MeshBuilderOptions {\n  size?: number;\n  includeGeomorph?: boolean;\n  defaultMaterial?: number;\n  foliageMaterial?: number;\n}\n\nexport interface MeshBuilder {\n  vertices: number[];\n  boxMin: number[];\n  boxMax: number[];\n  vertexStride: number;\n  includeGeomorph: boolean;\n  addTriangle: (\n    a: Vec3,\n    b: Vec3,\n    c: Vec3,\n    normal: Vec3,\n    color: Vec3,\n    swayA?: number,\n    swayB?: number,\n    swayC?: number,\n    material?: number,\n    morphA?: MeshGeomorph,\n    morphB?: MeshGeomorph,\n    morphC?: MeshGeomorph\n  ) => void;\n  addQuad: (\n    a: Vec3,\n    b: Vec3,\n    c: Vec3,\n    d: Vec3,\n    normal: Vec3,\n    color: Vec3,\n    swayA?: number,\n    swayB?: number,\n    swayC?: number,\n    swayD?: number,\n    material?: number,\n    morphA?: MeshGeomorph,\n    morphB?: MeshGeomorph,\n    morphC?: MeshGeomorph,\n    morphD?: MeshGeomorph\n  ) => void;\n  addTreeMesh: (center: Vec3, baseHeight: number, seedValue: number, material?: number) => void;\n  addBounds: (points: Vec3[], minY?: number, maxYOverride?: number) => void;\n  readonly treeMeshCount: number;\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport function normalize(vec: Vec3): Vec3 {\n  const len = Math.hypot(vec[0], vec[1], vec[2]);\n  if (len === 0) return [0, 1, 0];\n  return [vec[0] / len, vec[1] / len, vec[2] / len];\n}\n\nexport function computeNormal(a: Vec3, b: Vec3, c: Vec3): Vec3 {\n  const ab: Vec3 = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n  const ac: Vec3 = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n  return normalize([\n    ab[1] * ac[2] - ab[2] * ac[1],\n    ab[2] * ac[0] - ab[0] * ac[2],\n    ab[0] * ac[1] - ab[1] * ac[0],\n  ]);\n}\n\nexport function shade(color: Vec3, factor: number): Vec3 {\n  return [color[0] * factor, color[1] * factor, color[2] * factor];\n}\n\nexport function createMeshBuilder(sizeOrOptions: number | MeshBuilderOptions = 1): MeshBuilder {\n  const options: MeshBuilderOptions =\n    typeof sizeOrOptions === \"number\" ? { size: sizeOrOptions } : sizeOrOptions;\n  const size = options.size ?? 1;\n  const includeGeomorph = options.includeGeomorph ?? false;\n  const defaultMaterial = options.defaultMaterial ?? 0;\n  const foliageMaterial = options.foliageMaterial ?? defaultMaterial;\n  const vertices: number[] = [];\n  const boxMin: number[] = [];\n  const boxMax: number[] = [];\n  let treeMeshCount = 0;\n\n  const vertexStride = includeGeomorph ? 13 : 11;\n\n  const pushVertex = (\n    pos: Vec3,\n    normal: Vec3,\n    color: Vec3,\n    sway = 0,\n    material = defaultMaterial,\n    geomorph?: MeshGeomorph\n  ) => {\n    vertices.push(\n      pos[0],\n      pos[1],\n      pos[2],\n      normal[0],\n      normal[1],\n      normal[2],\n      color[0],\n      color[1],\n      color[2],\n      sway,\n      material\n    );\n    if (includeGeomorph) {\n      const targetY = geomorph?.targetY ?? pos[1];\n      const weight = geomorph?.weight ?? 0;\n      vertices.push(targetY, weight);\n    }\n  };\n\n  const addTriangle = (\n    a: Vec3,\n    b: Vec3,\n    c: Vec3,\n    normal: Vec3,\n    color: Vec3,\n    swayA = 0,\n    swayB = swayA,\n    swayC = swayA,\n    material = defaultMaterial,\n    morphA?: MeshGeomorph,\n    morphB?: MeshGeomorph,\n    morphC?: MeshGeomorph\n  ) => {\n    pushVertex(a, normal, color, swayA, material, morphA);\n    pushVertex(b, normal, color, swayB, material, morphB);\n    pushVertex(c, normal, color, swayC, material, morphC);\n  };\n\n  const addQuad = (\n    a: Vec3,\n    b: Vec3,\n    c: Vec3,\n    d: Vec3,\n    normal: Vec3,\n    color: Vec3,\n    swayA = 0,\n    swayB = swayA,\n    swayC = swayA,\n    swayD = swayA,\n    material = defaultMaterial,\n    morphA?: MeshGeomorph,\n    morphB?: MeshGeomorph,\n    morphC?: MeshGeomorph,\n    morphD?: MeshGeomorph\n  ) => {\n    addTriangle(a, b, c, normal, color, swayA, swayB, swayC, material, morphA, morphB, morphC);\n    addTriangle(c, d, a, normal, color, swayC, swayD, swayA, material, morphC, morphD, morphA);\n  };\n\n  const addPrism = (\n    center: Vec3,\n    radius: number,\n    bottom: number,\n    height: number,\n    color: Vec3,\n    swayBase = 0,\n    swayScale = 0,\n    material = defaultMaterial\n  ) => {\n    const top: Vec3[] = [];\n    const base: Vec3[] = [];\n    const baseY = center[1] + bottom;\n    const topY = baseY + height;\n    const safeHeight = Math.max(height, 0.001);\n    const swayFor = (y: number) => swayBase + swayScale * clamp((y - baseY) / safeHeight, 0, 1);\n    for (let i = 0; i < 6; i += 1) {\n      const angle = (Math.PI / 180) * (60 * i - 30);\n      const x = center[0] + radius * Math.cos(angle);\n      const z = center[2] + radius * Math.sin(angle);\n      top.push([x, topY, z]);\n      base.push([x, baseY, z]);\n    }\n    const topCenter: Vec3 = [center[0], topY, center[2]];\n    const topSway = swayFor(topY);\n    for (let i = 0; i < 6; i += 1) {\n      const a = topCenter;\n      const b = top[i];\n      const c = top[(i + 1) % 6];\n      const normal = computeNormal(a, b, c);\n      addTriangle(a, b, c, normal, color, topSway, topSway, topSway, material);\n    }\n    for (let i = 0; i < 6; i += 1) {\n      const top0 = top[i];\n      const top1 = top[(i + 1) % 6];\n      const bottom0 = base[i];\n      const bottom1 = base[(i + 1) % 6];\n      const normal = computeNormal(top0, bottom0, bottom1);\n      const swayTop0 = swayFor(top0[1]);\n      const swayTop1 = swayFor(top1[1]);\n      const swayBottom0 = swayFor(bottom0[1]);\n      const swayBottom1 = swayFor(bottom1[1]);\n      addQuad(\n        top0,\n        bottom0,\n        bottom1,\n        top1,\n        normal,\n        shade(color, 0.85),\n        swayTop0,\n        swayBottom0,\n        swayBottom1,\n        swayTop1,\n        material\n      );\n    }\n  };\n\n  const addTreeMesh = (\n    center: Vec3,\n    baseHeight: number,\n    seedValue: number,\n    material = defaultMaterial\n  ) => {\n    const trunkRadius = size * (0.12 + seedValue * 0.05);\n    const trunkHeight = 0.5 + seedValue * 0.6;\n    const canopyRadius = size * (0.36 + seedValue * 0.18);\n    const canopyHeight = 0.6 + seedValue * 0.4;\n    const trunkColor: Vec3 = [0.28, 0.18, 0.1];\n    const leafColor: Vec3 = [0.18, 0.45, 0.2];\n\n    addPrism(center, trunkRadius, baseHeight, trunkHeight, trunkColor, 0.02, 0.28, material);\n    addPrism(\n      [center[0], baseHeight + trunkHeight * 0.7, center[2]],\n      canopyRadius,\n      0,\n      canopyHeight * 0.55,\n      leafColor,\n      0.12,\n      0.9,\n      foliageMaterial\n    );\n    addPrism(\n      [center[0], baseHeight + trunkHeight + canopyHeight * 0.1, center[2]],\n      canopyRadius * 0.7,\n      0,\n      canopyHeight * 0.35,\n      shade(leafColor, 0.95),\n      0.2,\n      1.1,\n      foliageMaterial\n    );\n    treeMeshCount += 1;\n  };\n\n  const addBounds = (points: Vec3[], minY = 0, maxYOverride?: number) => {\n    const xs = points.map((p) => p[0]);\n    const zs = points.map((p) => p[2]);\n    const ys = points.map((p) => p[1]);\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minZ = Math.min(...zs);\n    const maxZ = Math.max(...zs);\n    const maxY = typeof maxYOverride === \"number\" ? maxYOverride : Math.max(...ys);\n    boxMin.push(minX, minY, minZ, 0);\n    boxMax.push(maxX, maxY, maxZ, 0);\n  };\n\n  return {\n    vertices,\n    boxMin,\n    boxMax,\n    vertexStride,\n    includeGeomorph,\n    addTriangle,\n    addQuad,\n    addTreeMesh,\n    addBounds,\n    get treeMeshCount() {\n      return treeMeshCount;\n    },\n  };\n}\n"],"mappings":"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","names":["r","hash01","clamp","clamp01","module","entry","clamp"]}